<html>
<!-- this file was generated by troffcvt and tc2html -->
<head>
<title>
Using the Ruby MySQL Module 
</title>
</head>
<body>
<h1>
<center>
Using the Ruby MySQL Module<br>
</center><center>
</center>
</h1>
<center>
<p>
<i>Paul DuBois<br>
<a href="mailto:paul@kitebird.com">paul@kitebird.com<br>
</a></i>
</center>
<center>
<p>
Document revision: 1.06<br>
Last update: 2007-05-26<br>
</center>
<h2>
Table of Contents
</h2>
<!-- INSERT TOC HERE -->
<!-- TOC BEGIN -->
<ul>
<li>
<a href=#TOC_1>Introduction</a>
<li>
<a href=#TOC_2>Obtaining and Installing the MySQL Module</a>
<li>
<a href=#TOC_3>MySQL Module Overview</a>
<li>
<a href=#TOC_4>A Simple MySQL-Based Ruby Script</a>
<li>
<a href=#TOC_5>Processing Statements</a>
<ul>
<li>
<a href=#TOC_6>Processing Statements that Return No Result Set</a>
<li>
<a href=#TOC_7>Processing Statements that Return a Result Set</a>
<li>
<a href=#TOC_8>Detecting NULL Values in Result Sets</a>
<li>
<a href=#TOC_9>Including Special Characters in Statement Strings</a>
<li>
<a href=#TOC_10>Statement Result Metadata</a>
<li>
<a href=#TOC_11>Deferring Result Set Generation</a>
</ul>
<li>
<a href=#TOC_12>More on Establishing Connections</a>
<li>
<a href=#TOC_13>Deprecated Methods</a>
<li>
<a href=#TOC_14>Resources</a>
<li>
<a href=#TOC_15>Revision History</a>
</ul>
<!-- TOC END -->
<br>
<a name=TOC_1>
<h2>
Introduction
</h2>
</a><br>
<p>
Programs that access MySQL databases can be written in the Ruby
scripting language by using Tomita Masahiro's MySQL module. This
module provides a Ruby client API; it is implemented as a wrapper
around the MySQL C client API. This document describes how to
install the MySQL module and use it to write MySQL-based Ruby
scripts. A related document describes the Ruby DBI module that
provides a higher-level interface that is more abstract and database-independent.
See the &quot;Resources&quot; section for a pointer to that document
and also for information about downloading the example scripts
used here.<br>
<a name=TOC_2>
<h2>
Obtaining and Installing the MySQL Module
</h2>
</a><br>
<p>
To use the Ruby MySQL module, first make sure that you have the
MySQL C client API header files and libraries installed. This
is a requirement because the API provided by the Ruby module is
built on top of the C API.<br>
<p>
The Ruby MySQL module can be obtained from the following site:<br>
<pre>
   <a href="http://www.tmtm.org/en/mysql/ruby/">http://www.tmtm.org/en/mysql/ruby/
</a>
</pre>
The module is distributed as a compressed <i>tar</i> file, which
you should unpack after downloading it. For example, if the current
version is 2.7.1, the distribution file can be unpacked using
either of the following commands:<br>
<pre>
   % <b>tar zxf mysql-ruby-2.7.1.tar.gz</b>
   % <b>gunzip &lt; mysql-ruby-2.7.1.tar.gz | tar xf -</b>
</pre>
After unpacking the distribution, change location into its top-level
directory and configure it using the <i>extconf.rb</i> script
in that directory:<br>
<pre>
   % <b>ruby extconf.rb</b>
</pre>
If <i>extconf.rb</i> successfully locates your MySQL header file
and library directories, you can proceed to build and install
the module. Otherwise, it indicates what it could not find, and
you'll need to run the command again with additional options that
specify the appropriate directory locations. For example, if your
header file and library directories are <i>/usr/local/mysql/include/mysql</i>
and <i>/usr/local/mysql/include/lib</i>, the configuration command
looks like this:<br>
<pre>
   % <b>ruby extconf.rb \</b>
       <b>--with-mysql-include=/usr/local/mysql/include/mysql \</b>
       <b>--with-mysql-lib=/usr/local/mysql/lib/mysql</b>
</pre>
Alternatively, tell <i>extconf.rb</i> where to find the <i>mysql_config</i>
program. In that case, <i>extconf.rb</i> runs <i>mysql_config</i>
to locate the header and library files:<br>
<pre>
   % <b>ruby extconf.rb --with-mysql-config=/usr/local/mysql/bin/mysql_config</b>
</pre>
After configuring the distribution, build and install the module:<br>
<pre>
   % <b>make</b>
   % <b>make install</b>
</pre>
You might need to run the installation command as <tt>root</tt>.<br>
<p>
If you have problems getting the module installed, see the distribution's
<i>README</i> file for additional configuration and build information.<br>
<p>
The preceding instructions apply to Unix systems. It is possible
to install the module on Windows as well, but you need some sort
of Unix-like environment such as Cygwin. For links to pages that
provide Windows instructions, see the &quot;Resources&quot; section.<br>
<a name=TOC_3>
<h2>
MySQL Module Overview
</h2>
</a><br>
<p>
The MySQL module defines four classes:<br>
<ul>
<li>
<tt>Mysql</tt><br>
The main class; it provides methods for connecting to the server,
for sending SQL statements to the server, and for administrative
operations.<br>
<li>
<tt>Mysql::Result</tt><br>
The result set class, used for statements that produce a result
set.<br>
<li>
<tt>Mysql::Field</tt><br>
Metadata class; it provides information about the characteristics
of columns in a result set, such as their names, types, and other
attributes.<br>
<li>
<tt>Mysql::Error</tt><br>
The exception class, used when a method of one of the other classes
results in an error.<br>
</ul>
In most cases, Ruby methods in the module act as wrappers around
the corresponding functions in the C API, except that the Ruby
method names do not begin with a <tt>mysql_</tt> prefix. For example,
the Ruby <tt>real_connect</tt> method is a wrapper around the
C <tt>mysql_real_connect()</tt> function. (What this means is
that if you're wondering about something not discussed in this
document, you may be able to figure out what you want to know
by referring to the C API chapter in the MySQL Reference Manual
or by consulting other documentation that discusses the C API.)<br>
<a name=TOC_4>
<h2>
A Simple MySQL-Based Ruby Script
</h2>
</a><br>
<p>
With the Ruby MySQL module installed, you should be able to access
your MySQL server from within Ruby programs. Assume for purposes
of this article that the server is running on the local host and
that you have access to a database named <tt>test</tt> by connecting
using an account that has a username and password of <tt>testuser</tt>
and <tt>testpass</tt>. You can set up this account by using the
<i>mysql</i> program to connect to the server as the MySQL <tt>root</tt>
user and issuing the following statement:<br>
<pre>
   mysql&gt; <b>GRANT ALL ON test.* TO 'testuser'@'localhost' IDENTIFIED BY 'testpass';</b>
</pre>
If the <tt>test</tt> database does not exist, create it with this
statement:<br>
<pre>
   mysql&gt; <b>CREATE DATABASE test;</b>
</pre>
If you want to use a different server host, username, password,
or database name, just substitute the appropriate values in each
of the scripts discussed in the remainder of this article.<br>
<p>
As a first exercise in MySQL-based Ruby programming, let's create
a script named <i>simple.rb</i> that just connects to the server,
retrieves and displays the server version, and disconnects. Use
a text editor to create <i>simple.rb</i> with the following contents
(or download the script from the link listed in &quot;Resources&quot;):<br>
<pre>
   #!/usr/bin/ruby -w
   # simple.rb - simple MySQL script using Ruby MySQL module

   require &quot;mysql&quot;

   begin
     # connect to the MySQL server
     dbh = Mysql.real_connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;testpass&quot;, &quot;test&quot;)
     # get server version string and display it
     puts &quot;Server version: &quot; + dbh.get_server_info
   rescue Mysql::Error =&gt; e
     puts &quot;Error code: #{e.errno}&quot;
     puts &quot;Error message: #{e.error}&quot;
     puts &quot;Error SQLSTATE: #{e.sqlstate}&quot; if e.respond_to?(&quot;sqlstate&quot;)
   ensure
     # disconnect from server
     dbh.close if dbh
   end
</pre>
The script works as follows:<br>
<ul>
<li>
The <tt>require</tt> line tells Ruby to pull in the contents of
the MySQL module that you installed earlier. This line must be
present or none of the MySQL-related methods will be available
to the script.<br>
<li>
The MySQL module includes a class method named <tt>real_connect</tt>
that takes several arguments indicating how to make the connection
and that returns a database handle object. The number of arguments
can vary; as used in <i>simple.rb</i>, the arguments are the hostname
where the server is running, the username and password of the
MySQL account that you want to use, and the default database name.<br>
Some methods in the Ruby MySQL module have alternative names (aliases)
that you can use. <tt>real_connect</tt> is one of these; you can
invoke <tt>connect</tt> or <tt>new</tt> and they will have the
same effect as <tt>real_connect</tt>.<br>
<li>
The database handle is used to interact with the MySQL server
until you're done with it. The extent of this script's interaction
is to invoke the <tt>get_server_info</tt> method that returns
the server version string and then to terminate the connection
using <tt>close</tt>. The <tt>close</tt> call is placed within
an <tt>ensure</tt> clause so that connection termination occurs
even if an error happens during statement processing.<br>
</ul>
If <i>simple.rb</i> executes successfully when you run it, you
should see output something like this:<br>
<pre>
   % <b>ruby simple.rb</b>
   Server version: 5.1.14-beta-log
</pre>
If <i>simple.rb</i> does not execute successfully, an error will
occur. Methods in the MySQL module raise a <tt>Mysql::Error</tt>
exception when they fail. Exception objects have read-only <tt>error</tt>,
<tt>errno</tt>, and (for recent versions of the MySQL module)
<tt>sqlstate</tt> values that contain the error message string,
numeric error code, and five-character SQLSTATE value. The <tt>rescue</tt>
clause in <i>simple.rb</i> illustrates how to access the exception
values: It places a reference to the <tt>Mysql::Error</tt> exception
object in <tt>e</tt>, and the body of the block prints the <tt>errno</tt>,
<tt>error</tt>, and <tt>sqlstate</tt> values to provide information
about the cause of the failure. To see what happens when an exception
occurs, change one of the connection parameters in the <tt>real_connect</tt>
call to some invalid value (such as changing the username to an
invalid name), then run <i>simple.rb</i> again. It will display
error information as follows:<br>
<pre>
   % <b>ruby simple.rb</b>
   Error code: 1045
   Error message: Access denied for user 'nouser'@'localhost' (using password: YES)
   Error SQLSTATE: 28000
</pre>
<a name=TOC_5>
<h2>
Processing Statements
</h2>
</a><br>
<p>
Statements such as <tt>CREATE</tt> <tt>TABLE</tt>, <tt>INSERT</tt>,
<tt>DELETE</tt>, and <tt>UPDATE</tt> return no result set and
are quite easy to process. Statements such as <tt>SELECT</tt>
and <tt>SHOW</tt> do return rows; it takes a little more work
to process them. The following discussion shows how to handle
both types of statements. (The code is part of the <i>animal.rb</i>
script available for download as described in &quot;Resources.&quot;)<br>
<a name=TOC_6>
<h3>
Processing Statements that Return No Result Set
</h3>
</a><br>
<p>
To execute a statement that does not return a result set, invoke
the database handle's <tt>query</tt> method to send the statement
to the server. If you want to know how many rows the statement
affected, invoke <tt>affected_rows</tt> to get the count. The
following code demonstrates this by initializing a table named
<tt>animal</tt> that contains two columns, <tt>name</tt> and <tt>category</tt>.
It drops any existing version of the table, creates it anew, and
then inserts some sample data into it. Each of these operations
requires only an invocation of the <tt>query</tt> method to send
the appropriate statement to the server. After issuing the <tt>INSERT</tt>,
the script also invokes <tt>affected_rows</tt> to determine how
many rows were added to the table:<br>
<pre>
   dbh.query(&quot;DROP TABLE IF EXISTS animal&quot;)
   dbh.query(&quot;CREATE TABLE animal
              (
                name     CHAR(40),
                category CHAR(40)
              )
            &quot;)
   dbh.query(&quot;INSERT INTO animal (name, category)
                VALUES
                  ('snake', 'reptile'),
                  ('frog', 'amphibian'),
                  ('tuna', 'fish'),
                  ('racoon', 'mammal')
              &quot;)
   puts &quot;Number of rows inserted: #{dbh.affected_rows}&quot;
</pre>
<a name=TOC_7>
<h3>
Processing Statements that Return a Result Set
</h3>
</a><br>
<p>
To execute a statement that returns a result set, a typical sequence
of events is as follows:<br>
<ul>
<li>
Invoke <tt>query</tt> using the database handle to send the statement
to the server and get back a result set object (an instance of
the <tt>Mysql::Result</tt> class). A result set object is somewhat
analogous to what you might think of as a statement handle in
other APIs. It has methods for fetching rows, moving around in
the result set, obtaining column metadata, and releasing the result
set.<br>
<li>
Use a row fetching method such as <tt>fetch_row</tt> or an iterator
such as <tt>each</tt> to access the rows of the result set.<br>
<li>
If you want a count of the number of rows in the result set, invoke
its <tt>num_rows</tt> method.<br>
<li>
Invoke <tt>free</tt> to release the result set. After that point,
the result set is invalid and you should not invoke any of the
object's methods.<br>
</ul>
The following example shows how to display the contents of the
<tt>animal</tt> table by issuing a <tt>SELECT</tt> statement and
looping through the rows that it returns. It also prints a row
count using <tt>num_rows</tt> and releases the result set with
<tt>free</tt>:<br>
<pre>
   # issue a retrieval query, perform a fetch loop, print
   # the row count, and free the result set

   res = dbh.query(&quot;SELECT name, category FROM animal&quot;)

   while row = res.fetch_row do
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end
   puts &quot;Number of rows returned: #{res.num_rows}&quot;

   res.free
</pre>
The example fetches the rows using a <tt>while</tt> loop and the
result set's <tt>fetch_row</tt> method. Another approach is to
use the <tt>each</tt> iterator directly with the result set object:<br>
<pre>
   res = dbh.query(&quot;SELECT name, category FROM animal&quot;)

   res.each do |row|
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end
   puts &quot;Number of rows returned: #{res.num_rows}&quot;

   res.free
</pre>
<tt>fetch_row</tt> and <tt>each</tt> return successive rows of
the result, each row as an array of column values. There are hashed
versions of each of these that return rows as hashes keyed by
column name. The hash method, <tt>fetch_hash</tt> is used like
this:<br>
<pre>
   res = dbh.query(&quot;SELECT name, category FROM animal&quot;)

   while row = res.fetch_hash do
     printf &quot;%s, %s\n&quot;, row[&quot;name&quot;], row[&quot;category&quot;]
   end
   puts &quot;Number of rows returned: #{res.num_rows}&quot;

   res.free
</pre>
The hash iterator, <tt>each_hash</tt>, works like this:<br>
<pre>
   res = dbh.query(&quot;SELECT name, category FROM animal&quot;)

   res.each_hash do |row|
     printf &quot;%s, %s\n&quot;, row[&quot;name&quot;], row[&quot;category&quot;]
   end
   puts &quot;Number of rows returned: #{res.num_rows}&quot;

   res.free
</pre>
By default, hash keys in rows returned by <tt>fetch_hash</tt>
and <tt>each_hash</tt> are column names. This can result in loss
of values if multiple columns have the same name. For example,
the following statement produces two columns named <tt>i</tt>:<br>
<pre>
   SELECT t1.i, t2.i FROM t1, t2;
</pre>
Only one of the columns will be accessible if you process rows
as hashes. To disambiguate hash elements in such cases, you can
supply a <tt>with_table=true</tt> argument to <tt>fetch_hash</tt>
or <tt>each_hash</tt>. This causes each hash key to be qualified
with the appropriate table name, in <tt><i>tbl_name.col_name</i></tt>
format. It's still possible to lose values, because if you select
the same value from a table multiple times, they'll both have
the same qualified name--but since both columns will have the
same value anyway, it hardly matters.<br>
<p>
When you use <tt>with_table=true</tt>, remember to access column
values in row hashes with key values that include the table name.
For example:<br>
<pre>
   res = dbh.query(&quot;SELECT name, category FROM animal&quot;)

   res.each_hash(with_table = true) do |row|
     printf &quot;%s, %s\n&quot;, row[&quot;animal.name&quot;], row[&quot;animal.category&quot;]
   end
   puts &quot;Number of rows returned: #{res.num_rows}&quot;

   res.free
</pre>
If you use aliases in your statement, either for tables or columns,
those aliases are used in the hash keys rather than the original
table or column names.<br>
<p>
With <tt>fetch_row</tt> and <tt>each</tt>, you must know the order
in which column values are present in each row. This makes them
unsuitable for <tt>SELECT</tt> <tt>*</tt> statements because no
column order can be assumed. <tt>fetch_hash</tt> and <tt>each_hash</tt>
enable column values to be accessed by column name. They're less
efficient than the array versions, but more suited to processing
the results of <tt>SELECT</tt> <tt>*</tt> statements because you
need know nothing about order of columns within the result set.<br>
<p>
For result sets fetched with <tt>with_table=true</tt>, the <tt><i>tbl_name</i></tt>
part of the hash key is empty for columns calculated from expressions.
Suppose you issue the following statement:<br>
<pre>
   SELECT i, i+0, VERSION(), 4+2 FROM t;
</pre>
Only the first column comes directly from the table <tt>t</tt>,
so it's the only column for which the hash key contains a table
name. The hash keys for rows of the statement are <tt>&quot;t.i&quot;</tt>,
<tt>&quot;.i+0&quot;</tt>, <tt>&quot;.VERSION()&quot;</tt>, and
<tt>&quot;.4+2&quot;</tt>.<br>
<a name=TOC_8>
<h3>
Detecting NULL Values in Result Sets
</h3>
</a><br>
<p>
<tt>NULL</tt> values in result sets are represented by the Ruby
<tt>nil</tt> value. Beginning with the <tt>animal</tt> table used
thus far, we can insert a row containing <tt>NULL</tt> values
like this:<br>
<pre>
   dbh.query(&quot;INSERT INTO animal (name, category) VALUES (NULL, NULL)&quot;)
</pre>
The following code retrieves and prints the table contents:<br>
<pre>
   res = dbh.query(&quot;SELECT name, category FROM animal&quot;)

   res.each do |row|
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end

   res.free
</pre>
The output produced by the loop is as follows. Note that <tt>NULL</tt>
values show up as empty values in the last line of the output:<br>
<pre>
   snake, reptile
   frog, amphibian
   tuna, fish
   racoon, mammal
   ,
</pre>
To detect <tt>NULL</tt> values and print the word &quot;NULL&quot;
instead, the loop can look for <tt>nil</tt> values in the result:<br>
<pre>
   res.each do |row|
     row[0] = &quot;NULL&quot; if row[0].nil?
     row[1] = &quot;NULL&quot; if row[1].nil?
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end
</pre>
Now the output becomes:<br>
<pre>
   snake, reptile
   frog, amphibian
   tuna, fish
   racoon, mammal
   NULL, NULL
</pre>
Of course, individual column value testing quickly becomes ugly
as the number of columns increases. A more Ruby-like way to map
<tt>nil</tt> to a printable &quot;NULL&quot; is to use <tt>collect</tt>,
a technique that has the advantage of being a one-liner no matter
the number of columns:<br>
<pre>
   res.each do |row|
     row = row.collect { |v| v.nil? ? &quot;NULL&quot; : v }
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end
</pre>
Or, to modify the row in place, use the <tt>collect!</tt> method:<br>
<pre>
   res.each do |row|
     row.collect! { |v| v.nil? ? &quot;NULL&quot; : v }
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end
</pre>
<a name=TOC_9>
<h3>
Including Special Characters in Statement Strings
</h3>
</a><br>
<p>
Suppose we want to put a new animal into the <tt>animal</tt> table,
but we don't know its category. We could use &quot;don't know&quot;
as the <tt>category</tt> value, but a statement written as follows
raises an exception:<br>
<pre>
   dbh.query(&quot;INSERT INTO animal (name, category)
              VALUES ('platypus','don't know')&quot;)
</pre>
That statement contains a single quote within a single-quoted
string, which is syntactically illegal. To make the statement
legal, escape the quote with a backslash:<br>
<pre>
   dbh.query(&quot;INSERT INTO animal (name, category)
              VALUES ('platypus','don\'t know')&quot;)
</pre>
However, for an arbitrary data value (such as a value stored in
a variable), you might not know whether or not it contains any
special characters. To make the value safe for insertion as a
data value in a statement, use the <tt>escape_string</tt> method,
or its alias, <tt>quote</tt>. These methods map onto the C <tt>mysql_real_escape_string()</tt>
function if it is available and to the <tt>mysql_escape_string()</tt>
function otherwise.<br>
<p>
Using <tt>escape_string</tt>, the platypus record might be inserted
as follows:<br>
<pre>
   name = dbh.escape_string(&quot;platypus&quot;)
   category = dbh.escape_string(&quot;don't know&quot;)
   dbh.query(&quot;INSERT INTO animal (name, category)
              VALUES ('&quot; + name + &quot;','&quot; + category + &quot;')&quot;)
</pre>
Strictly speaking, it's unnecessary to process a <tt>name</tt>
value like <tt>&quot;platypus&quot;</tt> with <tt>escape_string</tt>,
because it contains no special characters. But it's not a bad
idea to develop the habit of escaping your data values, especially
if you obtain them from an external source such as a web script.<br>
<p>
Note that <tt>escape_string</tt> does not add any surrounding
quotes around data values; you'll need to do that yourself. Also,
take care about using <tt>escape_string</tt> to handle <tt>nil</tt>
values; it will throw an exception. If a data value is <tt>nil</tt>,
you should insert the literal word &quot;NULL&quot; into your
statement <i>without</i> surrounding quotes instead of invoking
<tt>escape_string</tt>.<br>
<a name=TOC_10>
<h3>
Statement Result Metadata
</h3>
</a><br>
<p>
For a statement that doesn't return any rows (such as <tt>INSERT</tt>),
the only statement metadata available is the number of rows affected.
This value can be obtained by invoking the <tt>affected_rows</tt>
method of your database handle.<br>
<p>
For a statement that does return rows (such as <tt>SELECT</tt>),
available metadata includes the number of rows and columns in
the result set, as well as information describing the characteristics
of each column, such as its name and type. All this information
is available through the result set object:<br>
<ul>
<li>
The <tt>num_rows</tt> and <tt>num_fields</tt> methods return the
number of rows and columns in the result set.<br>
<li>
Column information is available by invoking result set methods
that return <tt>Mysql::Field</tt> objects. Each such object contains
metadata about one column of the result.<br>
</ul>
Metadata cannot be obtained from a result set object after you
release it by calling <tt>free</tt>.<br>
<p>
If you know whether a statement returns rows, you can tell in
advance which metadata methods are appropriate for obtaining information
about the statement result. If you don't know, you can determine
which methods are applicable using the result from <tt>query</tt>.
If <tt>query</tt> returns <tt>nil</tt>, there is no result set.
Otherwise use the value as a result set object through which the
metadata can be obtained.<br>
<p>
The following example shows how to use this technique to display
metadata for any arbitrary statement, assumed here to be stored
as a string in the <tt>stmt</tt> variable. The script issues the
statement and examines the result set to determine which types
of metadata are available:<br>
<pre>
   res = dbh.query(stmt)

   puts &quot;Statement: #{stmt}&quot;
   if res.nil? then
     puts &quot;Statement has no result set&quot;
     printf &quot;Number of rows affected: %d\n&quot;, dbh.affected_rows
   else
     puts &quot;Statement has a result set&quot;
     printf &quot;Number of rows: %d\n&quot;, res.num_rows
     printf &quot;Number of columns: %d\n&quot;, res.num_fields
     res.fetch_fields.each_with_index do |info, i|
       printf &quot;--- Column %d (%s) ---\n&quot;, i, info.name
       printf &quot;table:            %s\n&quot;, info.table
       printf &quot;def:              %s\n&quot;, info.def
       printf &quot;type:             %s\n&quot;, info.type
       printf &quot;length:           %s\n&quot;, info.length
       printf &quot;max_length:       %s\n&quot;, info.max_length
       printf &quot;flags:            %s\n&quot;, info.flags
       printf &quot;decimals:         %s\n&quot;, info.decimals
     end
     res.free
   end
</pre>
<a name=TOC_11>
<h3>
Deferring Result Set Generation
</h3>
</a><br>
<p>
When using the MySQL C client library, you typically process a
statement by calling <tt>mysql_query()</tt> or <tt>mysql_real_query()</tt>
to send the statement string to the server, <tt>mysql_store_result()</tt>
to generate the result set, a row-fetching function to get the
rows of the result set, and <tt>mysql_free_result()</tt> to release
the result set.<br>
<p>
By default, the Ruby <tt>query</tt> method handles the first two
parts of that process. That is, it sends the statement string
to the server and then automatically invokes <tt>store_result</tt>
to generate the result set, which it returns as a <tt>Mysql::Result</tt>
object.<br>
<p>
If you want to suppress automatic result set generation by <tt>query</tt>,
set your database handle's <tt>query_with_result</tt> variable
to <tt>false</tt>:<br>
<pre>
   dbh.query_with_result = false
</pre>
The effect of this is that after invoking <tt>query</tt>, you
must generate the result set yourself before fetching its rows.
To do so, invoke either <tt>store_result</tt> or <tt>use_result</tt>
explicitly to obtain the result set object. This in fact the approach
you <i>must</i> use if you want to retrieve rows with <tt>use_result</tt>:<br>
<pre>
   dbh.query(&quot;SELECT name, category FROM animal&quot;)
   res = dbh.use_result

   while row = res.fetch_row do
     printf &quot;%s, %s\n&quot;, row[0], row[1]
   end
   puts &quot;Number of rows returned: #{res.num_rows}&quot;

   res.free
</pre>
Note that if you fetch rows with <tt>use_result</tt>, the row
count will not be correct until after you have fetched all the
rows. (With <tt>store_result</tt>, the row count is correct as
soon as you generate the result set.)<br>
<a name=TOC_12>
<h2>
More on Establishing Connections
</h2>
</a><br>
<p>
As shown earlier, you connect to the server by invoking <tt>real_connect</tt>
as a class method to obtain a database handle object:<br>
<pre>
   dbh = Mysql.real_connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;testpass&quot;, &quot;test&quot;)
</pre>
It's also possible to connect by first invoking the <tt>init</tt>
class method to obtain a database handle object, and then invoking
<tt>real_connect</tt> as a method of that object:<br>
<pre>
   dbh = Mysql.init
   dbh.real_connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;testpass&quot;, &quot;test&quot;)
</pre>
In itself, this approach doesn't gain you anything over invoking
<tt>real_connect</tt> as a class method. Its advantage is that
it enables you to specify options that afford more specific control
over the connection. To do this, invoke the object's <tt>options</tt>
method one or more times before invoking <tt>real_connect</tt>.
<tt>options</tt> takes two arguments indicating an option type
and its value. The names correspond to the symbolic constants
used for the C <tt>mysql_options()</tt> function. For example,
if you want to connect using parameters listed in the <tt>[client]</tt>
group in the standard option files, rather than specifying them
in the <tt>real_connect</tt> call, do this:<br>
<pre>
   dbh = Mysql.init
   dbh.options(Mysql::READ_DEFAULT_GROUP, &quot;client&quot;)
   dbh.real_connect
</pre>
The <tt>real_connect</tt> method takes up to seven parameters.
The full invocation syntax is:<br>
<pre>
   real_connect(<i>host</i>,<i>user</i>,<i>password</i>,<i>db</i>,<i>port</i>,<i>socket</i>,<i>flags</i>)
</pre>
The <tt><i>host</i></tt>, <tt><i>user</i></tt>, <tt><i>password</i></tt>,
and <tt><i>db</i></tt> parameters have already been discussed.<br>
<p>
The <tt><i>port</i></tt> and <tt><i>socket</i></tt> parameters
indicate the port number (for TCP/IP connections) and the Unix
domain socket file pathname (for connections to <tt>localhost</tt>).
They can be used to override the defaults (which typically are
3306 and <i>/tmp/mysql.sock</i>).<br>
<p>
The <tt><i>flags</i></tt> argument can be used to specify additional
connection flags. The allowable flag names correspond to the symbolic
constants used for the C <tt>mysql_real_connect()</tt> function.
The flag values are bit values and can be OR-ed or added together.
For example, if you want to connect using the compressed client/server
protocol and to tell the server to use the interactive-client
timeout value, specify the <tt><i>flags</i></tt> value like this:<br>
<pre>
   Mysql::CLIENT_COMPRESS | Mysql::CLIENT_INTERACTIVE
</pre>
Or like this:<br>
<pre>
   Mysql::CLIENT_COMPRESS + Mysql::CLIENT_INTERACTIVE
</pre>
<a name=TOC_13>
<h2>
Deprecated Methods
</h2>
</a><br>
<p>
The Ruby MySQL module mirrors the C API fairly closely and provides
bindings to most of the C client functions. Several of the C API
functions are deprecated and to be avoided, which means that you
should also try to avoid the corresponding Ruby methods. You can
do this without any loss of functionality in your Ruby scripts;
the reason functions in the C API become deprecated is that they
are superceded by other ways to achieve the same effect. For example,
the <tt>mysql_create_db()</tt> function now is deprecated because
you can issue a <tt>CREATE</tt> <tt>DATABASE</tt> SQL statement
with <tt>mysql_query()</tt> or <tt>mysql_real_query()</tt>. Correspondingly,
instead of using the Ruby <tt>create_db</tt> method to create
a database, do this:<br>
<pre>
   dbh.query(&quot;CREATE DATABASE <i>db_name</i>&quot;)
</pre>
<a name=TOC_14>
<h2>
Resources
</h2>
</a><br>
<p>
The scripts that are used for examples in this document can be
downloaded from the following location:<br>
<pre>
   <a href="http://www.kitebird.com/articles/">http://www.kitebird.com/articles/
</a>
</pre>
Another document at that location discusses database programming
using the database interface provided by the Ruby DBI module.<br>
<p>
The following references might be helpful as sources of information
about Ruby, the Ruby MySQL module, and the C API on which the
module is built:<br>
<ul>
<li>
The Ruby home page provides general information about Ruby itself:<br>
<pre>
   <a href="http://www.ruby-lang.org/en/">http://www.ruby-lang.org/en/
</a>
</pre>
<li>
Tomita Masahiro's site (home for the Ruby MySQL module):<br>
<pre>
   <a href="http://www.tmtm.org/en/mysql/ruby/">http://www.tmtm.org/en/mysql/ruby/
</a>
</pre>
Tomita's site also provides links to pages that have instructions
for installing the module on Windows.<br>
<li>
MySQL software and documentation can be obtained from MySQL AB:<br>
<pre>
   <a href="http://www.mysql.com/">http://www.mysql.com/
</a>
</pre>
The MySQL C API is defined in the MySQL Reference Manual:<br>
<pre>
   <a href="http://dev.mysql.com/doc/mysql/">http://dev.mysql.com/doc/mysql/
</a>
</pre>
<li>
A chapter containing an extensive discussion of the C API is provided
in the book <i>MySQL</i> (Sams Developer's Library). The chapter
is available online at the book's companion web site:<br>
<pre>
   <a href="http://www.kitebird.com/mysql-book/">http://www.kitebird.com/mysql-book/
</a>
</pre>
The book also contains a reference appendix listing all the data
types and functions in the C API.<br>
</ul>
<a name=TOC_15>
<h2>
Revision History
</h2>
</a><br>
<ul>
<li>
1.02, 2003-01-11--Note effect of using table or column aliases
on hash keys for rows returned as hashes.<br>
<li>
1.03, 2003-01-19--Add reference for MySQL web site. Modify most
scripts to invoke <tt>close</tt> within an <tt>ensure</tt> clause,
not within the main body of the <tt>begin</tt> statement. Adjust
discussion of <i>simple.rb</i> to match. Other minor modifications.<br>
<li>
1.04, 2003-04-01--Add reference for rubywizard.net article. Change
publisher for MySQL book. Clarify <tt>escape_string</tt> behavior
for <tt>nil</tt> values. Minor general revisions.<br>
<li>
1.05, 2006-11-28--Updates for more recent versions of Ruby MySQL
module: Class name changes: <tt>MysqlError</tt> becomes <tt>Mysql::Error</tt>,
and so forth; describe the <tt>sqlstate</tt> method. Minor general
revisions.<br>
</ul>
</body>
</html>
