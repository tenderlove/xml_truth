<html>
<!-- this file was generated by troffcvt and tc2html -->
<head>
<title>
Using the Ruby DBI Module 
</title>
</head>
<body>
<h1>
<center>
Using the Ruby DBI Module<br>
</center><center>
</center>
</h1>
<center>
<p>
<i>Paul DuBois<br>
<a href="mailto:paul@kitebird.com">paul@kitebird.com<br>
</a></i>
</center>
<center>
<p>
Document revision: 1.03<br>
Last update: 2006-11-28<br>
</center>
<h2>
Table of Contents
</h2>
<!-- INSERT TOC HERE -->
<!-- TOC BEGIN -->
<ul>
<li>
<a href=#TOC_1>Introduction</a>
<li>
<a href=#TOC_2>Prerequisites</a>
<li>
<a href=#TOC_3>Installation</a>
<li>
<a href=#TOC_4>A Simple DBI Script</a>
<li>
<a href=#TOC_5>Processing SQL Statements</a>
<ul>
<li>
<a href=#TOC_6>Processing Statements that Return No Result Set</a>
<li>
<a href=#TOC_7>Processing Statements that Return a Result Set</a>
<li>
<a href=#TOC_8>Quoting, Placeholders, and Parameter Binding</a>
<li>
<a href=#TOC_9>Statement Result Metadata</a>
</ul>
<li>
<a href=#TOC_10>Methods That Take Code Blocks</a>
<li>
<a href=#TOC_11>More on Connecting to the Server</a>
<li>
<a href=#TOC_12>Error Handling and Debugging</a>
<li>
<a href=#TOC_13>Transaction Support</a>
<li>
<a href=#TOC_14>Accessing Driver-Specific Capabilities</a>
<li>
<a href=#TOC_15>Other DBI Goodies</a>
<li>
<a href=#TOC_16>Resources</a>
<li>
<a href=#TOC_17>Revision History</a>
</ul>
<!-- TOC END -->
<br>
<a name=TOC_1>
<h2>
Introduction
</h2>
</a><br>
<p>
The Ruby DBI module provides a database-independent interface
for Ruby scripts similar to that of the Perl DBI module. This
document describes how to write Ruby DBI-based scripts. It is
an adjunct to and not a substitute for the Ruby DBI specification
documents. See the &quot;Resources&quot; section for a pointer
to the specifications and also for information about downloading
the example scripts used here.<br>
<p>
The general architecture for Ruby DBI uses two layers:<br>
<ul>
<li>
The database interface (DBI) layer. This layer is database independent
and provides a set of common access methods that are used the
same way regardless of the type of database server with which
you're communicating.<br>
<li>
The database driver (DBD) layer. This layer is database dependent;
different drivers provide access to different database engines.
There is one driver for MySQL, another for PostgreSQL, another
for InterBase, another for Oracle, and so forth. Each driver interprets
requests from the DBI layer and maps them onto requests appropriate
for a given type of database server.<br>
</ul>
The examples in this document use the MySQL database driver, but
for many of them you should be able to substitute other drivers.
Some of the MySQL-specific features require Ruby DBI 0.1.1 or
higher.<br>
<a name=TOC_2>
<h2>
Prerequisites
</h2>
</a><br>
<p>
The Ruby DBI module includes the code that implements the general
DBI layer, as well as a set of DBD-level drivers. Many of these
drivers require that you have additional software installed. For
example, the database driver for MySQL is written in Ruby and
provides a binding to the Ruby MySQL module, which itself is written
in C and provides a binding to the MySQL C client API. This means
that if you want to write DBI scripts to access MySQL databases,
you'll need to have both the Ruby MySQL module and the C API installed.
For further information on the Ruby MySQL module, see the document
referenced in the &quot;Resources&quot; section. Here, I assume
that the MySQL module is installed and available for use by DBI.<br>
<a name=TOC_3>
<h2>
Installation
</h2>
</a><br>
<p>
After you have satisfied the prerequisites described in the previous
section, you can install the Ruby DBI module, which can be obtained
from the following site:<br>
<pre>
   <a href="http://rubyforge.org/projects/ruby-dbi/">http://rubyforge.org/projects/ruby-dbi/
</a>
</pre>
The DBI module is distributed as a compressed <i>tar</i> file,
which you should unpack after downloading it. For example, if
the current version is 0.1.1, the distribution file can be unpacked
using either of the following commands:<br>
<pre>
   % <b>tar zxf dbi-0.1.1.tar.gz</b>
   % <b>gunzip &lt; dbi-0.1.1.tar.gz | tar xf -</b>
</pre>
After unpacking the distribution, change location into its top-level
directory and configure it using the <i>setup.rb</i> script in
that directory. The most general configuration command looks like
this, with no arguments following the <tt>config</tt> argument:<br>
<pre>
   % <b>ruby setup.rb config</b>
</pre>
That command configures the distribution to install all drivers
by default. To be more specific, provide a <i>--with</i> option
that lists the particular parts of the distribution you want to
use. For example, to configure only the main DBI module and the
MySQL DBD-level driver, issue the following command:<br>
<pre>
   % <b>ruby setup.rb config --with=dbi,dbd_mysql</b>
</pre>
After configuring the distribution, build and install it:<br>
<pre>
   % <b>ruby setup.rb setup</b>
   % <b>ruby setup.rb install</b>
</pre>
You might need to run the installation command as <tt>root</tt>.<br>
<p>
The rest of this document uses the following notational conventions:<br>
<ul>
<li>
&quot;DBI module&quot; refers collectively to the DBI layer as
well as the DBD-level drivers, unless context indicates that only
the database independent layer is meant.<br>
<li>
&quot;<tt>DBD::Mysql</tt>&quot; refers to the MySQL-specific database
driver for DBI.<br>
<li>
&quot;Ruby MySQL module&quot; refers to the module on which <tt>DBD::Mysql</tt>
is built (that is, the module that provides the bindings to the
MySQL C client library).<br>
</ul>
<a name=TOC_4>
<h2>
A Simple DBI Script
</h2>
</a><br>
<p>
With the Ruby DBI module installed, you should be able to access
your MySQL server from within Ruby programs. Assume for purposes
of this article that the server is running on the local host and
that you have access to a database named <tt>test</tt> by connecting
using an account that has a username and password of <tt>testuser</tt>
and <tt>testpass</tt>. You can set up this account by using the
<i>mysql</i> program to connect to the server as the MySQL <tt>root</tt>
user and issuing the following statement:<br>
<pre>
   mysql&gt; <b>GRANT ALL ON test.* TO 'testuser'@'localhost' IDENTIFIED BY 'testpass';</b>
</pre>
If the <tt>test</tt> database does not exist, create it with this
statement:<br>
<pre>
   mysql&gt; <b>CREATE DATABASE test;</b>
</pre>
If you want to use a different server host, username, password,
or database name, just substitute the appropriate values in each
of the scripts discussed in the remainder of this article.<br>
<p>
The following script, <i>simple.rb</i>, is a short DBI program
that just connects to the server, retrieves and displays the server
version, and disconnects. You can download the script from the
link listed in the &quot;Resources&quot; section, or use a text
editor to create it directly:<br>
<pre>
   #!/usr/bin/ruby -w
   # simple.rb - simple MySQL script using Ruby DBI module

   require &quot;dbi&quot;

   begin
     # connect to the MySQL server
     dbh = DBI.connect(&quot;DBI:Mysql:test:localhost&quot;, &quot;testuser&quot;, &quot;testpass&quot;)
     # get server version string and display it
     row = dbh.select_one(&quot;SELECT VERSION()&quot;)
     puts &quot;Server version: &quot; + row[0]
   rescue DBI::DatabaseError =&gt; e
     puts &quot;An error occurred&quot;
     puts &quot;Error code: #{e.err}&quot;
     puts &quot;Error message: #{e.errstr}&quot;
   ensure
     # disconnect from server
     dbh.disconnect if dbh
   end

</pre>
The <i>simple.rb</i> script provides a very basic general overview
of DBI concepts. The immediately following discussion explains
how it works, and later sections show other examples that provide
additional detail on specific aspects of DBI programming.<br>
<p>
<i>simple.rb</i> begins with a <tt>require</tt> line that pulls
in the DBI module; without that line, DBI methods will fail. The
rest of the script is placed within a <tt>begin/rescue/ensure</tt>
construct:<br>
<ul>
<li>
The <tt>begin</tt> block handles all the database processing.<br>
<li>
The <tt>rescue</tt> clause handles any exceptions that occur;
it obtains and displays error information.<br>
<li>
The <tt>ensure</tt> clause make sure that the script closes any
open connection to the database server.<br>
</ul>
The <tt>connect</tt> method establishes a connection to the database
server and returns a database handle to use for further communication
with the server. The first argument is a data source name (DSN)
that indicates the driver name (which for MySQL is <tt>Mysql</tt>),
the default database name, and the hostname of the server. The
second and third arguments are the username and password of the
MySQL account to use. Other ways to write DSN values are covered
later in the section &quot;More on Connecting to the Server.&quot;<br>
<p>
<i>simple.rb</i> uses the database handle to call <tt>select_one</tt>,
a method that sends a statement to the server and returns the
first row of the result as an array. The <tt>SELECT</tt> <tt>VERSION()</tt>
statement returns a single value, so the version string is available
as <tt>row[0]</tt>, the first (and only) element of the array.
When you run the script, the result looks something like this:<br>
<pre>
   % <b>ruby simple.rb</b>
   Server version: 5.1.14-beta-log
</pre>
Errors cause exceptions to be raised. Various kinds of exceptions
can occur, but most of those related to database operations cause
a <tt>DatabaseError</tt> exception to be raised. Objects of this
exception class have <tt>err</tt>, <tt>errstr</tt>, and <tt>state</tt>
attributes that represent the error number, descriptive error
message, and SQLSTATE value. <i>simple.rb</i> prints the error
number and message for database exceptions, and ignores other
types of exceptions. (Should another exception occur, it is passed
back to Ruby itself for processing.)<br>
<p>
<i>simple.rb</i> terminates the connection to the server by invoking
the <tt>disconnect</tt> method. This is done in an <tt>ensure</tt>
clause to make sure that connection termination occurs even if
an error occurs during statement processing.<br>
<a name=TOC_5>
<h2>
Processing SQL Statements
</h2>
</a><br>
<p>
Ruby DBI provides many ways to execute statements. This section
discusses a few of them, but there are others.<br>
<p>
Many of the examples use a table named <tt>people</tt> that has
the following structure:<br>
<pre>
   CREATE TABLE people
   (
     id     INT UNSIGNED NOT NULL AUTO_INCREMENT, # ID number
     name   CHAR(20) NOT NULL,                    # name
     height FLOAT,                                # height in inches
     PRIMARY KEY (id)
   );
</pre>
<a name=TOC_6>
<h3>
Processing Statements that Return No Result Set
</h3>
</a><br>
<p>
Statements that do not return rows can be issued by invoking the
<tt>do</tt> database handle method. This method takes a statement
string argument and returns a count of the number of rows affected
by the statement. The following example uses <tt>do</tt> several
times to create the <tt>people</tt> table and populate it with
a small data set:<br>
<pre>
   dbh.do(&quot;DROP TABLE IF EXISTS people&quot;)
   dbh.do(&quot;CREATE TABLE people (
             id INT UNSIGNED NOT NULL AUTO_INCREMENT,
             name CHAR(20) NOT NULL,
             height FLOAT,
             PRIMARY KEY (id))&quot;)
   rows = dbh.do(&quot;INSERT INTO people (name,height)
                  VALUES
                    ('Wanda',62.5),
                    ('Robert',75),
                    ('Phillip',71.5),
                    ('Sarah',68)&quot;)
   puts &quot;Number of rows inserted: #{rows}&quot;
</pre>
For the <tt>INSERT</tt> statement, this script obtains the row
count and displays it to indicate how many rows were added to
the table.<br>
<a name=TOC_7>
<h3>
Processing Statements that Return a Result Set
</h3>
</a><br>
<p>
Statements such as <tt>SELECT</tt> or <tt>SHOW</tt> return rows.
To process such a statement, send it to the server for execution,
retrieve any rows in the result set that it generates, and dispose
of the result set.<br>
<p>
One way to do this is to call <tt>prepare</tt> to generate a statement
handle. Use that handle to execute the statement and fetch its
results, and then call <tt>finish</tt> to dispose of the result
set:<br>
<pre>
   sth = dbh.prepare(<i>statement</i>)
   sth.execute
<i>   ... fetch rows ...</i>
   sth.finish
</pre>
It's also possible to pass the statement directly to <tt>execute</tt>
and skip the call to <tt>prepare</tt>:<br>
<pre>
   sth = dbh.execute(<i>statement</i>)
<i>   ... fetch rows ...</i>
   sth.finish
</pre>
There are many ways to fetch results after executing a statement.
You can call <tt>fetch</tt> as a standalone method in a loop until
it returns <tt>nil</tt>:<br>
<pre>
   sth = dbh.execute(&quot;SELECT * FROM people&quot;)
   while row = sth.fetch do
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;, row[0], row[1], row[2]
   end
   sth.finish
</pre>
<tt>fetch</tt> can also be used as an iterator, in which case
it is the same as <tt>each</tt>. The following two row-fetching
loops are equivalent:<br>
<pre>
   sth = dbh.execute(&quot;SELECT * FROM people&quot;)
   sth.fetch do |row|
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;, row[0], row[1], row[2]
   end
   sth.finish

   sth = dbh.execute(&quot;SELECT * FROM people&quot;)
   sth.each do |row|
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;, row[0], row[1], row[2]
   end
   sth.finish
</pre>
<tt>fetch</tt> and <tt>each</tt> produce <tt>DBI::Row</tt> objects,
which have several methods for accessing their contents:<br>
<ul>
<li>
Column values can be accessed by index or name using array notation:<br>
<pre>
   val = row[2]
   val = row[&quot;height&quot;]
</pre>
<li>
You can use a row object with <tt>by_index</tt> or <tt>by_field</tt>
to access column values by number or by name:<br>
<pre>
   val = row.by_index(2)
   val = row.by_field(&quot;height&quot;)
</pre>
<li>
An iterator method, <tt>each_with_name</tt>, produces each column
value along with the column name:<br>
<pre>
   row.each_with_name do |val, name|
     printf &quot;%s: %s, &quot;, name, val.to_s
   end
   print &quot;\n&quot;
</pre>
<li>
<tt>DBI::Row</tt> objects have a <tt>column_names</tt> method
that returns an array containing the names for each column. <tt>field_names</tt>
is an alias for <tt>column_names</tt>.<br>
</ul>
Other row-fetching methods include <tt>fetch_array</tt> and <tt>fetch_hash</tt>.
These do not return <tt>DBI::Row</tt> objects. Instead, they return
the next row as an array or a hash, or <tt>nil</tt> if there are
no more rows. Hashes returned by <tt>fetch_hash</tt> are keyed
by column name with column values as hash values. Either method
can be invoked in standalone fashion or as an iterator. The following
examples demonstrate this for <tt>fetch_hash</tt>:<br>
<pre>
   sth = dbh.execute(&quot;SELECT * FROM people&quot;)
   while row = sth.fetch_hash do
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;,
            row[&quot;id&quot;], row[&quot;name&quot;], row[&quot;height&quot;]
   end
   sth.finish

   sth = dbh.execute(&quot;SELECT * FROM people&quot;)
   sth.fetch_hash do |row|
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;,
            row[&quot;id&quot;], row[&quot;name&quot;], row[&quot;height&quot;]
   end
   sth.finish
</pre>
You can avoid the execute-fetch-finish sequence by using database
handle methods that do all the work for you and return the results:<br>
<pre>
   row = dbh.select_one(<i>statement</i>)
   rows = dbh.select_all(<i>statement</i>)
</pre>
<tt>select_one</tt> executes a statement and returns the first
row as an array, or <tt>nil</tt> if the statement returns no rows.
<tt>select_all</tt> returns an array of <tt>DBI::Row</tt> objects.
You can access the contents of these objects as discussed earlier.
The array is empty if the statement returns no rows.<br>
<p>
The MySQL driver examines the metadata for the result set and
uses it to coerce row values to the corresponding Ruby data type.
(This means, for example,, that <tt>id</tt>, <tt>name</tt>, and
<tt>height</tt> values retrieved from the <tt>people</tt> table
are returned as <tt>Fixnum</tt>, <tt>String</tt>, and <tt>Float</tt>
objects.) However, be aware that if a column value is <tt>NULL</tt>,
it is represented as <tt>nil</tt> in the result set and has a
type of <tt>NilClass</tt>. Also note that this coercion behavior
does not appear to be mandated by the DBI specification and might
not be performed by all drivers.<br>
<a name=TOC_8>
<h3>
Quoting, Placeholders, and Parameter Binding
</h3>
</a><br>
<p>
Ruby DBI provides a placeholder mechanism that enables you to
avoid including data values literally in a statement string. Instead,
you use special '<tt>?</tt>' placeholder markers within the statement
to indicate where the data values go. When you execute the statement,
you provide values to be bound to the placeholders. DBI substitutes
the values into the statement where the placeholders appear, performing
any quoting of string values and escaping of special characters
as necessary. This makes it easy to construct statements without
having to know whether the values contain special characters,
and without having to do any quote processing yourself. The placeholder
mechanism also properly handles <tt>NULL</tt> values; provide
<tt>nil</tt> as a data value and it is placed into the statement
as an unquoted <tt>NULL</tt> value.<br>
<p>
The following example illustrates how this works. Suppose you
want to add a new row to the <tt>people</tt> table for someone
named Na'il (a name that includes a quote), who is 76 inches tall.
To indicate where the data values go in the <tt>INSERT</tt> statement,
use '<tt>?</tt>' placeholder markers (without any surrounding
quotes), and provide the data values as additional arguments to
<tt>do</tt> following the statement:<br>
<pre>
   dbh.do(&quot;INSERT INTO people (id, name, height) VALUES(?, ?, ?)&quot;,
          nil, &quot;Na'il&quot;, 76)
</pre>
The resulting statement produced by <tt>do</tt> and sent to the
server looks like this:<br>
<pre>
   INSERT INTO people (id,name,height) VALUES(NULL,'Na\'il',76)
</pre>
If you plan to execute a statement multiple times, you can prepare
it first to obtain a statement handle, and then execute it with
the data values as arguments. Assume that a data file named <i>people.txt</i>
contains lines of tab-delimited name/height pairs to be inserted
into the <tt>people</tt> table. The following example reads the
file to obtain row data, executing a prepared <tt>INSERT</tt>
statement once for each row:<br>
<pre>
   # prepare statement for use within insert loop
   sth = dbh.prepare(&quot;INSERT INTO people (id, name, height) VALUES(?, ?, ?)&quot;)

   # read each line from file, split into values, and insert into database
   File.open(&quot;people.txt&quot;, &quot;r&quot;) do |f|
     f.each_line do |line|
       name, height = line.chomp.split(&quot;\t&quot;)
       sth.execute(nil, name, height)
     end
   end
</pre>
Preparing a statement first and then executing it multiple times
within a loop is more efficient than invoking <tt>do</tt> each
time through the loop (which in effect calls both <tt>prepare</tt>
and <tt>execute</tt> for each iteration). The difference is most
significant for database engines that prepare a query execution
plan and reuse it for each call to <tt>execute</tt>. MySQL doesn't
do this; Oracle does.<br>
<p>
To use placeholders for <tt>SELECT</tt> statements, the proper
strategy depends on whether you prepare the statement first:<br>
<ul>
<li>
If you invoke <tt>prepare</tt> to obtain a statement handle, use
that handle to call <tt>execute</tt> and pass it the data values
to be bound to the placeholders:<br>
<pre>
   sth = dbh.prepare(&quot;SELECT * FROM people WHERE name = ?&quot;)
   sth.execute(&quot;Na'il&quot;)
   sth.fetch do |row|
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;, row[0], row[1], row[2]
   end
   sth.finish
</pre>
<li>
If you don't use <tt>prepare</tt>, the first argument to <tt>execute</tt>
is the statement and the following arguments are the data values:<br>
<pre>
   sth = dbh.execute(&quot;SELECT * FROM people WHERE name = ?&quot;, &quot;Na'il&quot;)
   sth.fetch do |row|
     printf &quot;ID: %d, Name: %s, Height: %.1f\n&quot;, row[0], row[1], row[2]
   end
   sth.finish
</pre>
</ul>
Other drivers might allow or require that you represent placeholders
differently. For example, you might write placeholders as <tt>:</tt><tt><i>name</i></tt>
or <tt>:</tt><tt><i>n</i></tt> to specify them in named or numbered
form. Consult the documentation for the driver that you want to
use.<br>
<p>
The <tt>quote</tt> method performs quoting and escaping of a data
value and returns the result. This can be useful for constructing
statements to be executed by other programs. For example, if you
want to read the data file <i>people.txt</i> and convert it to
a set of <tt>INSERT</tt> statements that can be processed by a
program such as the <i>mysql</i> command-line client, do this:<br>
<pre>
   # read each line from file, split into values, and write INSERT statement
   File.open(&quot;people.txt&quot;, &quot;r&quot;) do |f|
     f.each_line do |line|
       name, height = line.chomp.split(&quot;\t&quot;)
       printf &quot;INSERT INTO people (id, name, height) VALUES(%s, %s, %s);\n&quot;,
              dbh.quote(nil), dbh.quote(name), dbh.quote(height)
     end
   end
</pre>
<a name=TOC_9>
<h3>
Statement Result Metadata
</h3>
</a><br>
<p>
For statements that return no result set, such as <tt>INSERT</tt>
or <tt>DELETE</tt>, the <tt>do</tt> method returns a count of
the number of rows processed.<br>
<p>
For statements that return rows, such as <tt>SELECT</tt>, you
can use the statement handle after invoking <tt>execute</tt> to
get row and column counts or information about each of the columns
in the result set:<br>
<ul>
<li>
The row and column counts are not available directly. To get the
row count, either count the rows as you fetch them, or fetch them
into a data structure and see how many elements it contains. To
get the column count, you can determine it from the number of
column names, available as <tt>sth.column_names.size</tt>.<br>
<li>
The <tt>column_info</tt> method returns information about each
column.<br>
</ul>
This script shows how to obtain metadata for a statement:<br>
<pre>
   sth = dbh.execute(stmt)

   puts &quot;Statement: #{stmt}&quot;
   if sth.column_names.size == 0 then
     puts &quot;Statement has no result set&quot;
     printf &quot;Number of rows affected: %d\n&quot;, sth.rows
   else
     puts &quot;Statement has a result set&quot;
     rows = sth.fetch_all
     printf &quot;Number of rows: %d\n&quot;, rows.size
     printf &quot;Number of columns: %d\n&quot;, sth.column_names.size
     sth.column_info.each_with_index do |info, i|
       printf &quot;--- Column %d (%s) ---\n&quot;, i, info[&quot;name&quot;]
       printf &quot;sql_type:         %s\n&quot;, info[&quot;sql_type&quot;]
       printf &quot;type_name:        %s\n&quot;, info[&quot;type_name&quot;]
       printf &quot;precision:        %s\n&quot;, info[&quot;precision&quot;]
       printf &quot;scale:            %s\n&quot;, info[&quot;scale&quot;]
       printf &quot;nullable:         %s\n&quot;, info[&quot;nullable&quot;]
       printf &quot;indexed:          %s\n&quot;, info[&quot;indexed&quot;]
       printf &quot;primary:          %s\n&quot;, info[&quot;primary&quot;]
       printf &quot;unique:           %s\n&quot;, info[&quot;unique&quot;]
       printf &quot;mysql_type:       %s\n&quot;, info[&quot;mysql_type&quot;]
       printf &quot;mysql_type_name:  %s\n&quot;, info[&quot;mysql_type_name&quot;]
       printf &quot;mysql_length:     %s\n&quot;, info[&quot;mysql_length&quot;]
       printf &quot;mysql_max_length: %s\n&quot;, info[&quot;mysql_max_length&quot;]
       printf &quot;mysql_flags:      %s\n&quot;, info[&quot;mysql_flags&quot;]
     end
   end
   sth.finish
</pre>
Members of <tt>column_info</tt> objects are accessible two ways.
The script just shown accesses them using hash member notation,
but you can also access them using <tt>info.</tt><tt><i>member_name</i></tt>
notation. For example, you can get the column name using either
of these values:<br>
<pre>
   info.[&quot;name&quot;]
   info.name
</pre>
Note: Older versions of this document stated that you can get
the row count for a <tt>SELECT</tt> result as <tt>sth.rows</tt>.
That is not supported. (It currently does happen to work for the
MySQL driver, but you should not rely on this behavior.)<br>
<a name=TOC_10>
<h2>
Methods That Take Code Blocks
</h2>
</a><br>
<p>
Some handle-creating methods can be invoked with a code block.
When executed this way, they provide the handle to the code block
as its parameter, and automatically clean up the handle when the
block terminates:<br>
<ul>
<li>
<tt>DBI.connect</tt> generates a database handle, for which it
calls <tt>disconnect</tt> if necessary at the end of the block.<br>
<li>
<tt>dbh.prepare</tt> generates a statement handle, for which it
calls <tt>finish</tt> at the end of the block. Within the block,
you must invoke <tt>execute</tt> to execute the statement.<br>
<li>
<tt>dbh.execute</tt> is similar except you don't invoke <tt>execute</tt>
within the block; the statement handle is automatically executed.<br>
</ul>
The following example illustrates use of a code block with each
of those handle-creating methods:<br>
<pre>
   # connect can take a code block, passes the database handle to it,
   # and automatically disconnects the handle at the end of the block

   DBI.connect(&quot;DBI:Mysql:test:localhost&quot;, &quot;testuser&quot;, &quot;testpass&quot;) do |dbh|

     # prepare can take a code block, passes the statement handle
     # to it, and automatically calls finish at the end of the block

     dbh.prepare(&quot;SHOW DATABASES&quot;) do |sth|
       sth.execute
       puts &quot;Databases: &quot; + sth.fetch_all.join(&quot;, &quot;)
     end

     # execute can take a code block, passes the statement handle
     # to it, and automatically calls finish at the end of the block

     dbh.execute(&quot;SHOW DATABASES&quot;) do |sth|
       puts &quot;Databases: &quot; + sth.fetch_all.join(&quot;, &quot;)
     end
   end
</pre>
There is also a <tt>transaction</tt> method that takes a code
block. It is described in &quot;Transaction Support.&quot;<br>
<a name=TOC_11>
<h2>
More on Connecting to the Server
</h2>
</a><br>
<p>
The <i>simple.rb</i> script shown earlier connects to the server
using the DBI <tt>connect</tt> method as follows:<br>
<pre>
   dbh = DBI.connect(&quot;DBI:Mysql:test:localhost&quot;, &quot;testuser&quot;, &quot;testpass&quot;)
</pre>
The first argument to <tt>connect</tt> is the data source name
(DSN); it identifies the type of connection to make. The other
two arguments are the username and password of your MySQL account.<br>
<p>
The DSN can be given in any of the following formats:<br>
<pre>
   DBI:<i>driver_name</i>
   DBI:<i>driver_name</i>:<i>db_name</i>:<i>host_name</i>
   DBI:<i>driver_name</i>:<i>param=val</i>;<i>param=val</i>...
</pre>
The DSN always begins with <tt>DBI</tt> or <tt>dbi</tt> (in uppercase
or lowercase, but not in mixed case) and the driver name. For
MySQL, the driver name is <tt>Mysql</tt>, and it's best to use
exactly that capitalization. (There is some indication in the
DBI specification that lettercase of the driver name should not
matter, but that is not always true up through DBI versions as
recent as 0.0.18.) For other drivers, you'll need to use the appropriate
driver name.<br>
<p>
<tt>DBI</tt> (or <tt>dbi</tt>) and the driver name must always
be given in the DSN. If nothing follows the driver name, the driver
may (I think) attempt to connect using a default database and
host name. The second format requires two values, a database name
and hostname separated by a colon. The third format allows a list
of parameter assignments to be specified following the second
colon (which is required), in <tt><i>param</i></tt><tt>=</tt><tt><i>value</i></tt>
format separated by semicolons. The following DSNs are all equivalent:<br>
<pre>
   DBI:Mysql:test:localhost
   DBI:Mysql:host=localhost;database=test
   DBI:Mysql:database=test;host=localhost
</pre>
The DSN syntax that uses <tt><i>param</i></tt><tt>=</tt><tt><i>value</i></tt>
format is the most flexible because it allows the parameters to
be specified in any order. It also allows for the possibility
of driver-specific parameters, which means that drivers can be
extensible in the connection parameters they accept. For MySQL,
several of the parameters correspond to arguments of the <tt>mysql_real_connect()</tt>
C API function:<br>
<ul>
<li>
<tt>host=</tt><tt><i>host_name</i></tt><br>
The host where the MySQL server runs<br>
<li>
<tt>database=</tt><tt><i>db_name</i></tt><br>
The database name<br>
<li>
<tt>port=</tt><tt><i>port_num</i></tt><br>
The TCP/IP port number, for non-<tt>localhost</tt> connections<br>
<li>
<tt>socket=</tt><tt><i>path_name</i></tt><br>
The pathname of the Unix socket file, for <tt>localhost</tt> connections<br>
<li>
<tt>flag=</tt><tt><i>num</i></tt><br>
Flags to enable<br>
</ul>
MySQL programs can read options from option files, as described
in the MySQL Reference Manual. Two DSN parameters enable Ruby
DBI scripts to use this capability:<br>
<ul>
<li>
<tt>mysql_read_default_file=</tt><tt><i>file_name</i></tt><br>
Read options only from the named option file.<br>
<li>
<tt>mysql_read_default_group=</tt><tt><i>group_name</i></tt><br>
Read options from the <tt>[</tt><tt><i>group_name</i></tt><tt>]</tt>
option group (and from the <tt>[client]</tt> group, if <tt><i>group_name</i></tt>
differs from <tt>client</tt>).<br>
</ul>
If neither option is given, option files are not used. If only
<tt>mysql_read_default_group</tt> is given, options are read from
the standard option files (such as <i>.my.cnf</i> in your home
directory and <i>/etc/my.cnf</i> on Unix). The following example
shows how to connect using any <tt>[client]</tt> group options
in the standard option files:<br>
<pre>
   dsn = &quot;DBI:Mysql:mysql_read_default_group=client&quot;
   dbh = DBI.connect(dsn,nil,nil)
</pre>
Other DSN options:<br>
<ul>
<li>
<tt>mysql_compression={0|1}</tt><br>
Disable or enable compression in the client/server protocol. The
default is not to use it.<br>
<li>
<tt>mysql_client_found_rows={0|1}</tt><br>
For statements that modify rows, MySQL by default returns a row
count of the number of rows actually changed. You can use <tt>mysql_client_found_rows=1</tt>
to tell the server to return a count of the rows matched by the
statement, regardless of whether they were changed. For example,
by default the following statement causes MySQL to return a row
count of 0 because no value in any row changes:<br>
<pre>
   UPDATE t SET id = id;
</pre>
With <tt>mysql_client_found_rows=1</tt>, the row count will be
equal to the number of rows in the table.<br>
</ul>
<a name=TOC_12>
<h2>
Error Handling and Debugging
</h2>
</a><br>
<p>
If a DBI method fails, DBI raises an exception. DBI methods may
raise any of several types of exception, but for database-related
operations, the relevant exception class is <tt>DatabaseError</tt>.
Exception objects of this class have three attributes named <tt>err</tt>,
<tt>errstr</tt>, and <tt>state</tt>, which represent the error
number, a descriptive error string, and a &quot;standard&quot;
error code. For MySQL, these values correspond to the return values
of the <tt>mysql_errno()</tt>, <tt>mysql_error()</tt>, and <tt>mysql_sqlsate()</tt>
C API functions. You can obtain these values when an exception
occurs as follows:<br>
<pre>
   rescue DBI::DatabaseError =&gt; e
     puts &quot;An error occurred&quot;
     puts &quot;Error code: #{e.err}&quot;
     puts &quot;Error message: #{e.errstr}&quot;
     puts &quot;Error SQLSTATE: #{e.state}&quot;
</pre>
If your version of the MySQL Ruby module is old and does not provide
SQLSTATE information, <tt>e.state</tt> is <tt>nil</tt>.<br>
<p>
To get debugging information about what your script is doing as
it executes, you can enable tracing. To do this, you must first
load the <tt>dbi/trace</tt> module:<br>
<pre>
   require &quot;dbi/trace&quot;
</pre>
The <tt>dbi/trace</tt> module is not loaded automatically by the
<tt>dbi</tt> module because it is dependent on version 0.3.3 or
newer of the AspectR module, which may not be present on your
machine.<br>
<p>
The <tt>dbi/trace</tt> module provides a <tt>trace</tt> method
that controls the trace mode and output destination:<br>
<pre>
   trace(<i>mode</i>, <i>destination</i>)
</pre>
The <tt><i>mode</i></tt> value may be 0 (off), 1, 2, or 3, and
the <tt><i>destination</i></tt> should be an <tt>IO</tt> object.
The default values are 2 and <tt>STDERR</tt>, respectively.<br>
<p>
<tt>trace</tt> can be invoked as a class method to affect all
subsequently created handles, or as an object method for individual
driver, database, or statement handles. When invoked as an object
method, any other objects subsequently derived from that object
also inherit the trace setting. For example, if you enable tracing
on a database handle, statement handles created from it from that
point on are given the same trace setting.<br>
<a name=TOC_13>
<h2>
Transaction Support
</h2>
</a><br>
<p>
DBI provides a transaction abstraction. However, availability
of the abstraction depends on transaction support in your database
engine, and on a DBD-level implementation of the abstraction in
your driver. For the MySQL driver, this abstraction is not functional
prior to DBI 0.0.19, so you must perform transactions by explicitly
using statements that control the auto-commit level, commits,
and rollbacks. For example:<br>
<pre>
   dbh.do(&quot;SET AUTOCOMMIT=0&quot;)
   dbh.do(&quot;BEGIN&quot;)
<i>   ... statements that make up the transaction ...</i>
   dbh.do(&quot;COMMIT&quot;)
</pre>
For DBI 0.0.19 and up, you can use the transaction abstraction
with MySQL. One aspect of the abstraction enables the auto-commit
level to be set by assigning to the database handle <tt>AutoCommit</tt>
attribute:<br>
<pre>
   dbh['AutoCommit'] = true
   dbh['AutoCommit'] = false
</pre>
While auto-commit is disabled (set to <tt>false</tt>), you can
perform transactions two ways. The following examples illustrate
the two approaches, using an <tt>account</tt> table for which
funds are transferred from one person to another.<br>
<ul>
<li>
The first approach uses DBI's <tt>commit</tt> and <tt>rollback</tt>
methods to explicitly commit or cancel the transaction:<br>
<pre>
   dbh['AutoCommit'] = false
   begin
     dbh.do(&quot;UPDATE account SET balance = balance - 50 WHERE name = 'bill'&quot;)
     dbh.do(&quot;UPDATE account SET balance = balance + 50 WHERE name = 'bob'&quot;)
     dbh.commit
   rescue
     puts &quot;transaction failed&quot;
     dbh.rollback
   end
   dbh['AutoCommit'] = true
</pre>
<li>
The second approach uses the <tt>transaction</tt> method. This
is simpler, because it takes a code block containing the statements
that make up the transaction. The <tt>transaction</tt> method
executes the block, then invokes <tt>commit</tt> or <tt>rollback</tt>
automatically, depending on whether the block succeeds or fails:<br>
<pre>
   dbh['AutoCommit'] = false
   dbh.transaction do |dbh|
     dbh.do(&quot;UPDATE account SET balance = balance - 50 WHERE name = 'bill'&quot;)
     dbh.do(&quot;UPDATE account SET balance = balance + 50 WHERE name = 'bob'&quot;)
   end
   dbh['AutoCommit'] = true
</pre>
</ul>
<a name=TOC_14>
<h2>
Accessing Driver-Specific Capabilities
</h2>
</a><br>
<p>
DBI provides a <tt>func</tt> database-handle method that drivers
can use to make database-dependent features available. For example,
the MySQL C API provides a <tt>mysql_insert_id()</tt> function
that returns the most recent <tt>AUTO_INCREMENT</tt> value for
a connection. The Ruby MySQL module provides a binding to this
function via its <tt>insert_id</tt> database-handle method, and
<tt>DBD::Mysql</tt> in turn provides access to <tt>insert_id</tt>
via the DBI <tt>func</tt> mechanism.<br>
<p>
The first argument to <tt>func</tt> is the name of the database-specific
method that you want to use; any following arguments are those
required by the method. The <tt>insert_id</tt> method requires
no additional arguments, so to access the most recent <tt>AUTO_INCREMENT</tt>
value, do this:<br>
<pre>
   dbh.do(&quot;INSERT INTO people (name,height) VALUES('Mike',70.5)&quot;)
   id = dbh.func(:insert_id)
   puts &quot;ID for new record: #{id}&quot;
</pre>
Other driver-specific methods supported by <tt>DBD::Mysql</tt>
are:<br>
<pre>
   dbh.func(:createdb, <i>db_name</i>) Create a new database
   dbh.func(:dropdb, <i>db_name</i>)   Drop a database
   dbh.func(:reload)            Perform a reload operation
   dbh.func(:shutdown)          Shut down the server
</pre>
The <tt>createdb</tt> and <tt>dropdb</tt> methods are unavailable
unless your MySQL client library comes from a version older than
MySQL 4 (they correspond to deprecated functions that the Ruby
MySQL module does not support as of MySQL 4).<br>
<p>
As of DBI 0.1.1, a number of other <tt>func</tt> methods are available.
They correspond to several functions in the MySQL C API:<br>
<pre>
   String = dbh.func(:client_info)
   Fixnum = dbh.func(:client_version)
   String = dbh.func(:host_info)
   String = dbh.func(:info)
   Fixnum = dbh.func(:proto_info)
   String = dbh.func(:server_info)
   String = dbh.func(:stat)
   Fixnum = dbh.func(:thread_id)
</pre>
<p>
In some cases, use of a driver-specific function may offer specific
advantages, even if there is another way to accomplish the same
thing. For example, the value returned by the <tt>insert_id</tt>
function of <tt>DBD::Mysql</tt> can be obtained by issuing a <tt>SELECT</tt>
<tt>LAST_INSERT_ID()</tt> statement. Both return the same value
in most cases. However, the <tt>insert_id</tt> function is more
efficient because it returns a value that is stored on the client
side and can be accessed without issuing another statement. This
efficiency benefit comes at the cost of greater care in how you
use the function. Its value is reset for each statement executed,
so you must access it after issuing the statement that generates
an <tt>AUTO_INCREMENT</tt> value but before issuing any other
statement. By contrast, the value of <tt>LAST_INSERT_ID()</tt>
is stored on the server side and is more persistent; it is not
reset by other statements except those that also generate <tt>AUTO_INCREMENT</tt>
values.<br>
<a name=TOC_15>
<h2>
Other DBI Goodies
</h2>
</a><br>
<p>
The <tt>DBI::Utils</tt> module includes a few interesting methods:<br>
<ul>
<li>
<tt>DBI::Utils::measure</tt> takes a code block and measures how
long it takes to execute the code within the block. You can use
this method to measure the wallclock time for execution of a statement
as follows:<br>
<pre>
   elapsed = DBI::Utils::measure do
     dbh.do(stmt)
   end
   puts &quot;Statement: #{stmt}&quot;
   puts &quot;Elapsed time: #{elapsed}&quot;
</pre>
<li>
The <tt>DBI::Utils::TableFormatter</tt> module has an <tt>ascii</tt>
method for displaying the contents of a result set. The first
argument is an array of column names, and the second is an array
of row objects. To display the contents of the <tt>people</tt>
table, do this:<br>
<pre>
   sth = dbh.execute(&quot;SELECT * FROM people&quot;)
   rows = sth.fetch_all
   col_names = sth.column_names
   sth.finish
   DBI::Utils::TableFormatter.ascii(col_names, rows)
</pre>
The resulting output is:<br>
<pre>
   +----+---------+--------+
   | id | name    | height |
   +----+---------+--------+
   | 1  | Wanda   | 62.5   |
   | 2  | Robert  | 75.0   |
   | 3  | Phillip | 71.5   |
   | 4  | Sarah   | 68.0   |
   +----+---------+--------+
</pre>
<li>
The <tt>DBI::Utils::XMLFormatter</tt> module has <tt>row</tt>
and <tt>table</tt> methods for displaying individual result set
rows or an entire result set as XML. This makes it easy to generate
XML output from query results. The following example demonstrates
the <tt>table</tt> method:<br>
<pre>
   DBI::Utils::XMLFormatter.table(dbh.select_all(&quot;SELECT * FROM people&quot;))
</pre>
The resulting output is:<br>
<pre>
   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
   &lt;rows&gt;
   &lt;row&gt;
     &lt;id&gt;1&lt;/id&gt;
     &lt;name&gt;Wanda&lt;/name&gt;
     &lt;height&gt;62.5&lt;/height&gt;
   &lt;/row&gt;
   &lt;row&gt;
     &lt;id&gt;2&lt;/id&gt;
     &lt;name&gt;Robert&lt;/name&gt;
     &lt;height&gt;75.0&lt;/height&gt;
   &lt;/row&gt;
   &lt;row&gt;
     &lt;id&gt;3&lt;/id&gt;
     &lt;name&gt;Phillip&lt;/name&gt;
     &lt;height&gt;71.5&lt;/height&gt;
   &lt;/row&gt;
   &lt;row&gt;
     &lt;id&gt;4&lt;/id&gt;
     &lt;name&gt;Sarah&lt;/name&gt;
     &lt;height&gt;68.0&lt;/height&gt;
   &lt;/row&gt;
   &lt;/rows&gt;
</pre>
</ul>
The <tt>ascii</tt> and <tt>table</tt> methods support a number
of optional arguments that provide greater control over the output
format and destination. See the module source code for more information.<br>
<a name=TOC_16>
<h2>
Resources
</h2>
</a><br>
<p>
The scripts that are used for examples in this document can be
downloaded from the following location:<br>
<pre>
   <a href="http://www.kitebird.com/articles/">http://www.kitebird.com/articles/
</a>
</pre>
That location also provides access to a document, &quot;Using
the Ruby MySQL Module,&quot; that discusses the module that forms
the basis for <tt>DBD::Mysql</tt>, the DBD-level MySQL driver
for DBI.<br>
<p>
You may find the following additional resources helpful for using
Ruby DBI:<br>
<ul>
<li>
You can get the Ruby DBI module and specification documents from
the DBI RubyForge site:<br>
<pre>
   <a href="http://rubyforge.org/projects/ruby-dbi/">http://rubyforge.org/projects/ruby-dbi/
</a>
</pre>
<li>
The second edition of <i>MySQL Cookbook</i>, (O'Reilly, 2006)
adds Ruby DBI to the MySQL-access interfaces that it covers. The
book shows many Ruby DBI examples:<br>
<pre>
   <a href="http://www.kitebird.com/mysql-cookbook/">http://www.kitebird.com/mysql-cookbook/
</a>
</pre>
<li>
The AspectR Ruby module must be installed if you want to use the
<tt>dbi/trace</tt> module that provides DBI execution tracing.
You can get AspectR at its SourceForge site:<br>
<pre>
   <a href="http://aspectr.sourceforge.net/">http://aspectr.sourceforge.net/
</a>
</pre>
<li>
The Ruby home page provides general information about Ruby itself:<br>
<pre>
   <a href="http://www.ruby-lang.org/">http://www.ruby-lang.org/
</a>
</pre>
<li>
MySQL can be obtained at:<br>
<pre>
   <a href="http://www.mysql.com/">http://www.mysql.com/
</a>
</pre>
</ul>
<a name=TOC_17>
<h2>
Revision History
</h2>
</a><br>
<ul>
<li>
1.00, 2003-01-19--Original version.<br>
<li>
1.01, 2003-01-30--More info about <tt>insert_id</tt> driver-specific
function. Clarify efficiency benefits of <tt>prepare</tt>.<br>
<li>
1.02, 2003-05-27--Correct/clarify some comments in <tt>block.rb</tt>
script. Correct misconception about <tt>rows</tt> method for <tt>SELECT</tt>
statements. Describe transaction abstraction. Other minor updates.<br>
<li>
1.03, 2006-11-28--Updated for Ruby DBI 0.1.1: Describe how to
use the <tt>mysql_</tt><tt><i>xxx</i></tt> DSN parameters. Describe
how to get SQLSTATE error values. Metadata example script lists
the additional <tt>column_info</tt> values that now are available.
Describe new <tt>func</tt> methods. Other minor revisions.<br>
</ul>
</body>
</html>
