<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Why Ruby is an acceptable LISP</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta content="43.703188,-72.288237" name="ICBM" />
  <link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://www.randomhacks.net/xml/rsd" />
  <link rel="alternate" type="application/rss+xml" title="Random Hacks" href="http://www.randomhacks.net/xml/rss20/feed.xml" />
  <link rel="alternate" type="application/rss+xml" title="Random Hacks comments" href="http://www.randomhacks.net/xml/rss20/comments/feed.xml" />
  <link rel="alternate" type="application/rss+xml" title="Comments on Why Ruby is an acceptable LISP" href="http://www.randomhacks.net/xml/rss20/article/77/feed.xml" />
  <link rel="icon" type="image/gif" href="/images/theme/icon.gif" />
  <link href="/stylesheets/theme/randomhacks.css" media="all" rel="Stylesheet" type="text/css" />
  <link href="/stylesheets/user-styles.css" media="all" rel="Stylesheet" type="text/css" />
  <link href="/stylesheets/theme/print.css" media="print" rel="Stylesheet" type="text/css" />
  <script src="/javascripts/cookies.js" type="text/javascript"></script>
  <script src="/javascripts/prototype.js" type="text/javascript"></script>
  <script src="/javascripts/effects.js" type="text/javascript"></script>
  <script src="/javascripts/typo.js" type="text/javascript"></script>
  
  <script type="text/javascript"></script>
  
</head>

<body>
  <div id="container" class="clearfix">
      <div id="header">
        <div id="logo">
          <h1 id="sitename"><a href="/">Random Hacks</a></h1>
          <h2 id="subtitle">Technology and Other Fun Stuff</h2>
        </div>
      </div>
      
      <div id="search"> <form action="/articles/search" id="sform" method="get">
 <label for="q">Live Search:</label><input type="text" id="q" name="q" value="" size="15" />
<img alt="Spinner-blue" id="search_spinner" src="/images/spinner-blue.gif" style="display:none;" />
</form>
<script type="text/javascript">
//<![CDATA[
new Form.Element.Observer('q', 1, function(element, value) {new Ajax.Updater('search-results', '/live/search', {asynchronous:true, evalScripts:true, onComplete:function(request){Element.hide('search_spinner')}, onLoading:function(request){Element.show('search_spinner')}, parameters:'q=' + escape($F('q'))})})
//]]>
</script></div>
      
      
      <div id="content" class="clearfix">
        <div id="main">
          <!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
       xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
       xmlns:dc="http://purl.org/dc/elements/1.1/">
<rdf:Description
    rdf:about=""
    trackback:ping="http://www.randomhacks.net/articles/trackback/77"
    dc:title="Why Ruby is an acceptable LISP"
    dc:identifier="http://www.randomhacks.net/articles/read/77"
    dc:description="Years ago, I looked at Ruby and decided to ignore it. Ruby wasn&amp;#8217;t as popular as Python, and it wasn&amp;#8217;t as powerful as LISP. So why should I bother? Of course, we could turn those criteria around. What if Ruby were more popular than &lt;"
    dc:creator="emk"
    dc:date="2008-12-20T01:57:04-05:00" />
</rdf:RDF>
-->

<div class="post" onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_article'); }"  onmouseout="Element.hide('admin_article');" >
  <a href="/admin/content/edit/77" class="admintools" id="admin_article" style="display: none">edit</a>
  <h2>Why Ruby is an acceptable LISP</h2>
  <p class="auth">Posted by Eric Kidd
  <span class="typo_date" title="Sat, 03 Dec 2005 16:30:00 GMT">Sat, 03 Dec 2005 16:30:00 GMT</span></p>
  <p>Years ago, I looked at Ruby and decided to ignore it. Ruby wasn&#8217;t as
popular as Python, and it wasn&#8217;t as powerful as LISP. So why should I
bother?</p>

<p>Of course, we could turn those criteria around.  What if Ruby were more
popular than <em>LISP</em>, and more powerful than <em>Python</em>?  Would that be enough
to make Ruby interesting?</p>

<p>Before answering this question, we should decide what makes LISP so
powerful.  Paul Graham has <a href="http://www.paulgraham.com/icad.html" title="Revenge of the Nerds">written eloquently</a> about LISP&#8217;s virtues.  But, for the sake of argument, I&#8217;d like to boil them down to two things:</p>

<ol>
<li>LISP is a dense functional language.  </li>
<li>LISP has programmatic macros.</li>
</ol>

<p>As it turns out, Ruby compares well as a functional language, and it fakes
macros better than I&#8217;d thought.</p><h3>Ruby is a denser functional language than LISP</h3>

<p>A dense language lets you say things concisely, without obfuscation.  You
can see more of your program in one glance, and there aren&#8217;t as many places
for bugs to hide.  Beyond a certain point, the only way to make programs
denser is to use more powerful abstractions.</p>

<p>One particularly powerful abstraction is <code>lambda</code>.  Using <code>lambda</code>, you can
create a new function on the fly, pass it to other functions, and even
store it for later use.  For example, if you wanted to double each number
in a list, you might write:</p>

<div class="typocode"><pre><code class="typocode_lisp ">(mapcar (lambda (n) (* n 2)) mylist)</code></pre></div>

<p><code>mapcar</code> creates a new list by transforming each element of <code>mylist</code>.  The
transformation, in this case, could be read as &#8220;for each value <em>n</em>,
multiply <em>n</em> by two.&#8221;  In JavaScript, you&#8217;d write <code>lambda</code> as <code>function</code>,
which is perhaps a bit clearer:</p>

<div class="typocode"><pre><code class="typocode_javascript ">map(function (n) { return n*2 }, mylist)</code></pre></div>

<p>Of course, this is only a hint of what you can do with <code>lambda</code>.  Languages
which favor this style of programming are called <em>functional</em> languages,
because they work with functions.  A dense functional language can be very
concise indeed, and quite clear once you learn to read it.</p>

<p>How does Ruby stack up against LISP for functional programming?  Let&#8217;s
consider Paul Graham&#8217;s <a href="http://www.paulgraham.com/icad.html" title="Revenge of the Nerds">canonical example</a>, a function which creates
an accumulator:</p>

<div class="typocode"><pre><code class="typocode_lisp ">(defun foo (n) (lambda (i) (incf n i)))</code></pre></div>

<p>This code is marginally shorter in Ruby, and the notation will be more
familiar to C hackers:</p>

<div class="typocode"><pre><code class="typocode_ruby "><span class="keyword">def </span><span class="method">foo</span><span class="punct">(</span><span class="ident">n</span><span class="punct">)</span> <span class="ident">lambda</span> <span class="punct">{|</span><span class="ident">i</span><span class="punct">|</span> <span class="ident">n</span><span class="punct">+=</span><span class="ident">i</span><span class="punct">}</span> <span class="keyword">end</span>

<span class="ident">acc</span> <span class="punct">=</span> <span class="ident">foo</span> <span class="number">3</span>
<span class="ident">acc</span><span class="punct">.</span><span class="ident">call</span><span class="punct">(</span><span class="number">1</span><span class="punct">)</span>   <span class="comment"># --&gt; 4</span>
<span class="ident">acc</span><span class="punct">.</span><span class="ident">call</span><span class="punct">(</span><span class="number">10</span><span class="punct">)</span>  <span class="comment"># --&gt; 14</span>
<span class="ident">acc</span><span class="punct">.</span><span class="ident">call</span><span class="punct">(</span><span class="number">0</span><span class="punct">)</span>   <span class="comment"># --&gt; 14</span></code></pre></div>

<p>But there&#8217;s an interesting special case in Ruby which saves us even more
typing.  Consider a (very silly) function which takes a <code>lambda</code> as an
argument:</p>

<div class="typocode"><pre><code class="typocode_lisp ">;; Call 'fn' once for each natural number.
(defun each-natural-number (fn)
  (loop for n from 1 do (funcall fn n)))

;; Print 1, 2, 3...
(each-natural-number
 (lambda (n) (format t &quot;~D~%&quot; n)))</code></pre></div>

<p>Now, we <em>could</em> write the same function in Ruby:</p>

<div class="typocode"><pre><code class="typocode_ruby "><span class="keyword">def </span><span class="method">each_natural_number</span><span class="punct">(</span><span class="ident">fn</span><span class="punct">)</span>
  <span class="ident">n</span> <span class="punct">=</span> <span class="number">0</span>
  <span class="ident">loop</span> <span class="punct">{</span> <span class="ident">fn</span><span class="punct">.</span><span class="ident">call</span><span class="punct">(</span><span class="ident">n</span> <span class="punct">+=</span> <span class="number">1</span><span class="punct">)</span> <span class="punct">}</span>
<span class="keyword">end</span>

<span class="ident">each_natural_number</span><span class="punct">(</span><span class="ident">lambda</span> <span class="punct">{|</span><span class="ident">n</span><span class="punct">|</span> <span class="ident">puts</span> <span class="ident">n</span> <span class="punct">})</span></code></pre></div>

<p>But we can do better.  Let&#8217;s get rid of <code>lambda</code> and <code>fn</code> using <code>yield</code>:</p>

<div class="typocode"><pre><code class="typocode_ruby "><span class="keyword">def </span><span class="method">each_natural_number</span>
  <span class="ident">n</span> <span class="punct">=</span> <span class="number">0</span>
  <span class="ident">loop</span> <span class="punct">{</span> <span class="keyword">yield</span> <span class="ident">n</span> <span class="punct">+=</span> <span class="number">1</span> <span class="punct">}</span>
<span class="keyword">end</span>

<span class="ident">each_natural_number</span> <span class="punct">{|</span><span class="ident">n</span><span class="punct">|</span> <span class="ident">puts</span> <span class="ident">n</span> <span class="punct">}</span></code></pre></div>

<p>Yes, <code>yield</code> is a special-purpose hack, and yes, it only works for functions
which take a single <code>lambda</code>.  But in heavily functional code, <code>yield</code>
buys us a lot.  Compare:</p>

<div class="typocode"><pre><code class="typocode_ruby "><span class="punct">[</span><span class="number">1</span><span class="punct">,</span><span class="number">2</span><span class="punct">,</span><span class="number">3</span><span class="punct">].</span><span class="ident">map</span> <span class="punct">{|</span><span class="ident">n</span><span class="punct">|</span> <span class="ident">n</span><span class="punct">*</span><span class="ident">n</span> <span class="punct">}.</span><span class="ident">reject</span> <span class="punct">{|</span><span class="ident">n</span><span class="punct">|</span> <span class="ident">n</span><span class="punct">%</span><span class="number">3</span><span class="punct">==</span><span class="number">1</span> <span class="punct">}</span></code></pre></div>

<div class="typocode"><pre><code class="typocode_lisp ">(remove-if (lambda (n) (= (mod n 3) 1))
           (mapcar (lambda (n) (* n n))
                   '(1 2 3)))</code></pre></div>

<p>In a large program, the difference adds up.  (In LISP&#8217;s defense, it&#8217;s
possible to write a reader macro which makes <code>lambda</code> more concise.  But
this is rarely done.)</p>

<h3>Ruby gives you about 80% of what you want from macros</h3>

<p>At this point, the LISP hackers are saying, &#8220;A good syntax for <code>lambda</code>
is nice, but what about macros?&#8221;  And this is a good question.  LISP
macros are functions that:</p>

<ol>
<li>Run in the compiler, and</li>
<li>Transform custom syntax into raw LISP.</li>
</ol>

<p>The most common use of LISP macros is to avoid typing <code>lambda</code> quite so
much:</p>

<div class="typocode"><pre><code class="typocode_lisp ">(defmacro with-each-natural-number (n expr)
  `(each-natural-number (lambda (,n) ,expr)))

(with-each-natural-number n
  (format t &quot;~D~%&quot; n))</code></pre></div>

<p><code>defmacro</code> defines a function that takes a list as an argument, and returns
another list.  In this example, our macro is called every time the compiler
sees <code>with-each-natural-number</code>.  It uses LISP&#8217;s &#8220;backquote&#8221; syntax to
quickly construct a list from a template, filling in <em>n</em> and <em>expr</em>.  The
list is then passed back to the compiler.</p>

<p>Of course, this macro would be useless in Ruby, because it&#8217;s working around
a problem we don&#8217;t have.</p>

<p>The second most common use of LISP macros is to create mini-languages for
defining stuff:</p>

<div class="typocode"><pre><code class="typocode_lisp ">;; Generate some bindings to our database
;; using a hypothetical &quot;LISP on Rails.&quot;
(defmodel &lt;order&gt; ()
  (belongs-to &lt;customer&gt;)
  (has-many &lt;item&gt; :dependent? t))</code></pre></div>

<p>Using <a href="http://www.rubyonrails.org/">Ruby on Rails</a>, we could write:</p>

<div class="typocode"><pre><code class="typocode_ruby "><span class="keyword">class </span><span class="class">Order</span> <span class="punct">&lt;</span> <span class="constant">ActiveRecord</span><span class="punct">::</span><span class="constant">Base</span>
  <span class="ident">belongs_to</span> <span class="symbol">:customer</span>
  <span class="ident">has_many</span> <span class="symbol">:items</span><span class="punct">,</span> <span class="symbol">:dependent</span> <span class="punct">=&gt;</span> <span class="constant">true</span>
<span class="keyword">end</span></code></pre></div>

<p>Here, <code>belongs_to</code> is a class function.  When called, it adds a bunch of
member functions to <code>Order</code>.  The implementation is <a href="http://www.poignantguide.net/ruby/chapter-6.html#section3" title="Really, there's some Ruby metaprogramming here.  Scroll down a bit.">pretty ugly</a>, but the
interface is excellent.</p>

<p>The real test of any macro-like functionality is how often it gets used to
build mini-languages.  And Ruby scores well here: In addition to Rails,
there&#8217;s <a href="http://www.martinfowler.com/articles/rake.html">Rake</a> (for writing Makefiles), <a href="http://needle.rubyforge.org/chapter-4.html">Needle</a> (for connecting components),
<a href="http://www.ruby-doc.org/stdlib/libdoc/optparse/rdoc/classes/OptionParser.html">OptionParser</a> (for parsing command-line options), <a href="http://rubyforge.org/cgi-bin/viewcvs.cgi/dlcookbook/lib/gd/bgd.rb?rev=1.1&amp;cvsroot=dlcookbook&amp;content-type=text/vnd.viewcvs-markup">DL</a> (for talking to C
APIs), and countless others.  Ruby programmers write <em>everything</em> in Ruby.</p>

<p>Of course, there&#8217;s lots of <a href="http://www.paulgraham.com/onlisp.html">advanced LISP macros</a> which can&#8217;t be
easily ported to Ruby.  In particular, macros which actually <em>compile</em>
mini-languages haven&#8217;t appeared yet, although they might be possible with
enough work.  (Ryan Davis has done some promising work in this direction
with <a href="http://www.zenspider.com/ZSS/Products/ParseTree/">ParseTree</a> and <a href="http://www.zenspider.com/ZSS/Products/RubyInline/">RubyInline</a>, and I&#8217;ll be writing about related
techniques as I discover them.)</p>

<h3>Ruby&#8217;s libraries, community, and momentum are good</h3>

<p>So if LISP is still more powerful than Ruby, why not use LISP?  The typical
objections to programming in LISP are:</p>

<ol>
<li>There aren&#8217;t enough libraries.</li>
<li>We can&#8217;t hire LISP programmers.</li>
<li>LISP has gone nowhere in the past 20 years.</li>
</ol>

<p>These aren&#8217;t overwhelming objections, but they&#8217;re certainly worth
considering.</p>

<p>Once upon a time, <a href="http://www.lisp.org/HyperSpec/FrontMatter/index.html" title="Common Lisp HyperSpec">Common Lisp&#8217;s standard library</a> was considered
huge.  But today, it seems painfully tiny.  Java&#8217;s manuals fill a wall, and
Perl&#8217;s CPAN archive has a module for anything you can imagine.  Common
Lisp, in comparison, doesn&#8217;t even have standard way to talk to the network.</p>

<p>Similarly, LISP programmers are scarce.  If you&#8217;re around Boston, there&#8217;s a
small pool of grizzled hackers who can very nearly work magic.  Elsewhere,
there&#8217;s a thin scattering of curious young hackers.  But LISP has always
been a minority language.</p>

<p>Ruby, on the other hand, is growing rapidly in popularity.  The big driver
seems to be Rails, and the ramp-up started in late 2004.  If you&#8217;re trying
to launch a company, it&#8217;s more-or-less a <em>cliché</em> that every potential
employee is a Rails nut.  Rails will soon trickle back into ordinary web
consulting, and from there&#8211;eventually&#8211;into big business.</p>

<p>Ruby has also been around long enough to develop a good standard library,
and a <a href="http://docs.rubygems.org/read/book/1" title="RubyGems packaging system manual">large archive</a> of add-on libraries.  If you need to download a
web page, parse RSS, generate graphs, or call a SOAP API, you&#8217;re all set.</p>

<p>Now, given a choice between a powerful language, and popular language, it
may make <a href="http://www.paulgraham.com/avg.html" title="History of Viaweb">excellent sense</a> to pick the powerful one.  But if the
difference in power is minor, being popular has all sorts of nice
advantages.  In 2005, I&#8217;d think long and hard before choosing LISP over
Ruby.  I&#8217;d probably only do it if I needed optimized code, or macros which
acted as full-fledged compilers.</p>

<p>(Thank you to Michael Fromberger for reviewing an early draft of this essay.)</p>
</div>
<p class="meta">
  Tags <a href="/articles/tag/LISP" rel="tag">LISP</a>, <a href="/articles/tag/Macros" rel="tag">Macros</a>, <a href="/articles/tag/Recommended" rel="tag">Recommended</a>, <a href="/articles/tag/Ruby" rel="tag">Ruby</a>
</p>

  <a name="comments"></a><h4 class="blueblk">Comments</h4> 
    <ol class="comment-list" id="commentList">
  
    <li id="comment-78"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_78'); }"  onmouseout="Element.hide('admin_comment_78');" >
  <div id="admin_comment_78" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/78', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-78',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/78" class="admintools">edit</a></div>
  <a name="comment-78"></a>
  
  <cite><strong><a href="http://zifus.blogspot.com">Excellent Article</a></strong> </cite> said about 4 hours later:<br />
  <p>Eric, thank you for this excellent article.  I have toyed with Lisp for several years now, and while I agree it is more powerful, I have made the decision to build my sites in Ruby for many of the reasons you have cited.</p>


	<p>I am constantly re-evaluating my choice of language tools, and have wondered if I made a mistake not building my site in Lisp.  (It&#8217;s still in development now, but keep an eye our for Zifus around the first part of 2006).</p>


	<p>I recently read an article by the developers of reddit that suggested they are considering re-writing their site at some point in the future.  He cited as a specific difficulty with Lisp that many of the libraries that quickly become available in other languages are slower to appear in Lisp because of the smaller community.</p>


	<p>Who knows if he was dissembling to throw potential competitors (like me) off track, but in the end it doesn&#8217;t matter, the point is valid.  Whereas I have been incredibly happy with the progress of Rails as a framework, and I have been utterly delighted with my personal productivity in this wonderful framework.</p>


	<p>Excellent article, too bad I can post it on Zifus yet, but soon, very soon.</p>
</li><li id="comment-79"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_79'); }"  onmouseout="Element.hide('admin_comment_79');" >
  <div id="admin_comment_79" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/79', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-79',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/79" class="admintools">edit</a></div>
  <a name="comment-79"></a>
  
  <cite><strong>zlxcgrogdss</strong> </cite> said about 5 hours later:<br />
  <p>I&#8217;m looking forward to your next editorial, perhaps it could be titled something like &#8220;Why Java is an acceptable Forth&#8221;. Maybe, if I&#8217;m lucky, &#8220;Why assembly is an acceptable binary&#8221;.</p>


	<p>What I&#8217;m, err, hinting at, is that Ruby is not Lisp. A Lisp is a Lisp because it&#8217;s code is represented as its basic data structure. Ruby&#8217;s isn&#8217;t (unless you argue that Ruby&#8217;s code consists of strings, and string is a baic data structure; though I&#8217;m sure you&#8217;ll agree that this would be pure sophistry). Lisp without this property is like a wheel that isn&#8217;t round.</p>


	<p>The above distinction, along with all of its implications, is the reason Ruby can not be a substitute for Lisp, which, I am assuming, was what you meant to say when you erroneously called Ruby &#8220;a Lisp&#8221;. Ruby is neat and all, but let&#8217;s not get carried away.</p>
</li><li id="comment-80"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_80'); }"  onmouseout="Element.hide('admin_comment_80');" >
  <div id="admin_comment_80" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/80', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-80',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/80" class="admintools">edit</a></div>
  <a name="comment-80"></a>
  
  <cite><strong>bill a</strong> </cite> said about 6 hours later:<br />
  <p>I took basically the opposite path &#8211; I abanboned Ruby in favor of Lisp.</p>


	<p>You have some good points, and I agree that Ruby is the most Lispy language that isn&#8217;t actually a Lisp (CL, Scheme, Dylan).  But although blocks can get you surprisingly close to macros, they can&#8217;t take you all the way there.  As you pointed out, the implementation of macro-like code in Ruby tends to be ugly behind the scenes.  Ruby&#8217;s syntax isn&#8217;t regular, and so can&#8217;t be operated on with macros.  This means you&#8217;ve got to shoehorn various abstractions into doing what you want.  Instead of processing the code passed to a block as a list and simply transforming it into something else, you have to define the elements of your mini-language as methods in some class.  The pervasiveness of Ruby&#8217;s OO becomes a hassle here.  (Sure, lots of defmacro&#8217;s end up being ugly too, but at least they&#8217;re conceptually cleaner).  And all user-defined languages and structures immediately stand out because they have to be set off with the &#8220;do&#8221; keyword.</p>


	<p>There are too many things about Lisp that no other language will ever get unless it is also a Lisp.  The ability to move through sexp&#8217;s with Emacs keychords is priceless.  The simple structure of Lisp and its lack of arbitrary syntax makes it easy to provide good editing support.  The whole idea of interactive development rocks.  The ability to, in most implementations, compile to native code rocks as well.  Lisp is pretty mature, and while there are a few quirks to it, 50 years of existence will go a long way toward making a programming language great.</p>


	<p>I guess what bothers me about Ruby is its quirks.  That might sound crazy, since it&#8217;s well-known that Common Lisp has more than its share of historical cruft.  But I really cannot get my mind back into the framework of arbitrary syntax.  It is ultimately useless.  It prevents you from writing macros, it prevents editors from having flawless support for your language, and it prevents you from expressing yourself as concisely as you need to.</p>


	<p>Your lambda sample is indeed shorter in Ruby than in Lisp.  But Ruby&#8217;s OO is not quite so clean in this situation:</p>


	<pre><code>(defmethod sum-children ((c item))
  (loop for child in (children-of item)
        sum (height-of child)))</code></pre>


	<pre><code>(mapcar #'sum-children list-o-children)</code></pre>


	<p>I don&#8217;t think that can be done quite so easily in Ruby.  The best I can come up with is:</p>


	<pre><code>class Item
  def sum_children
    children.inject( 0 ) { |c, s| c.height + s }
  end
end</code></pre>


	<pre><code>list_o_children.map { |c| c.sum_children }</code></pre>


	<p>It isn&#8217;t possible to (easily?) treat the concept of summing the children&#8217;s height as a function to pass to others.</p>


	<p>Also, blocks are little more than callable code.  You can try to impose some structure on them by defining appropriate methods and evaluating the block in a special context, but this is not the same as the code transformation macros provide.  You cannot, for instance, selectively evaluate different expressions in different contexts.  Consider:</p>


	<pre><code>(let ((x 45))
  (defclass foo ()
    ((name :initform x))))</code></pre>


	<p>That will work because defclass will expand the initform (and only the initform!) into a lambda-expression and thus close over the x variable; nothing else will be evaluated in that context.   It&#8217;s also important to notice that defclass does not look any different than let, even though defclass is simply a macro, and let is a built-in special form.</p>


	<p>I will clearly go on for days unless I stop now.  I was about to write about how let&#8217;s rock because you can limit a variable&#8217;s scope with absolute precision (not possible in Ruby) and then about how Marco Baringer implemented continuations in straight Lisp.  To sum up: yes, Ruby is not that bad (maybe even &#8220;acceptable&#8221;) but Lisp owns.</p>
</li><li id="comment-82" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_82'); }"  onmouseout="Element.hide('admin_comment_82');" >
  <div id="admin_comment_82" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/82', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-82',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/82" class="admintools">edit</a></div>
  <a name="comment-82"></a>
  
  <cite><strong>Eric</strong> </cite> said about 7 hours later:<br />
  <p>Ruby&#8217;s most frustrating quirks, from a <span class="caps">LISP</span> perspective, tend to involve its scoping rules.  Methods, variables and constants each have subtly different behavior.  And as for block locals, even Matz admits that they&#8217;re pretty broken.</p>


	<p>Let&#8217;s consider a Ruby version of <span class="caps">LET</span>:</p>


<pre>
def let(*args) yield *args end
let(1,2,3) {|x,y,z| z }
</pre>

	<p>This does exactly what you want <em>if</em> the variables are unbound: It introduces a new scope with three local variables.  On the other hand, if any of the variables were previously bound, Ruby clobbers the existing bindings.  Nasty.</p>


	<p>The biggest limitation of trading <span class="caps">LISP</span>&#8217;s compile-time macro expansion for Ruby&#8217;s metaclass hackery is launch time.  Rails works around this using <span class="caps">FCGI</span> and on-demand class loading.</p>


	<p>These headaches aside, I&#8217;ve had very good luck porting <span class="caps">LISP</span> macros to Ruby.  At this point, I could probably reimplement about half of the macros in <em>On <span class="caps">LISP</span></em> without much trouble.  Another quarter could be brute-forced using ParseTree, but that&#8217;s (arguably) cheating.  I&#8217;ll talk more about these techniques in the coming months.</p>
</li><li id="comment-83"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_83'); }"  onmouseout="Element.hide('admin_comment_83');" >
  <div id="admin_comment_83" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/83', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-83',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/83" class="admintools">edit</a></div>
  <a name="comment-83"></a>
  
  <cite><strong>Anonymous</strong> </cite> said about 7 hours later:<br />
  <p>Hi. I&#8217;ll just assume here you always meant Common Lisp when you wrote <span class="caps">LISP</span> (it isn&#8217;t capitalised there, just like <span class="caps">PERL</span> and <span class="caps">JAVA</span> aren&#8217;t right).</p>


<blockquote>
	<p>Before answering this question, we should decide what makes <span class="caps">LISP</span> so powerful. Paul Graham has written eloquently about <span class="caps">LISP</span>’s virtues. But, for the sake of argument, I’d like to boil them down to two things:
	LISP is a dense functional language.
	LISP has programmatic macros.</p>

</blockquote>




	<p>Sorry to say, but that doesn&#8217;t reflect reality. If those were the two main reasons to use Common Lisp, most people probably wouldn&#8217;t.
Incidentally, Paul Graham&#8217;s Common Lisp style is definitely atypical (google for &#8220;Graham Crackers&#8221;). His Scheme background/affection certainly shows, and he usually doesn&#8217;t mention all the other things that make Common Lisp so useful (unlike in Scheme, avoiding side-effects and using recursion instead of iteration in Common Lisp is rather rare).
Despite the roots, Common Lisp isn&#8217;t much of a &#8220;functional&#8221; language. It has all the necessary features, but imperative constructs and <span class="caps">OOP</span> play a major role in the language. It&#8217;s not Common Lisp if it doesn&#8217;t have the Common Lisp Object System; it also wouldn&#8217;t be anywhere as powerful without the  condition system and all the other things (full numeric tower; the type system; etc.).</p>


	<p>I have no doubt that Ruby might match CL in the functional department, but that won&#8217;t get you very far. Common Lisp has come a long way, and even though many people seem to reduce it to macros and higher-order functions, that view does certainly not reflect the way people use it in reality&#8212;it&#8217;s not very attractive or particularly useful (in comparison) when reduced to that set of features.</p>


<blockquote>
	<p>2005, I’d think long and hard before choosing <span class="caps">LISP</span> over Ruby. I’d probably only do it if I needed optimized code, or macros which acted as full-fledged compilers.</p>

</blockquote>




	<p>I&#8217;m sure Ruby is a good choice, but if you&#8217;re using Lisp just for the macros, you&#8217;ve probably missed all the <em>interesting</em> features&#8230; 
(In case you&#8217;re curious, Practical Common Lisp is a good, freely available book that covers a lot more ground than just macros and higher-order functions)</p>
</li><li id="comment-84"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_84'); }"  onmouseout="Element.hide('admin_comment_84');" >
  <div id="admin_comment_84" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/84', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-84',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/84" class="admintools">edit</a></div>
  <a name="comment-84"></a>
  
  <cite><strong><a href="http://null">null</a></strong> </cite> said about 9 hours later:<br />
  <p>You guys don&#8217;t understand&#8230;your precious little languages is a moving target. You&#8217;ll never write code that&#8217;ll survive 20 years with them.
If all you&#8217;re doing is web pages, I suppose that&#8217;s all right. But only to a point where data integration and AI comes to the web.
Than, Ruby, Perl and Python are gone.</p>


	<p>What Lisp needs is more people. If the lisp community had /half/ of the people who enthusiastically throw themselves full hearted in every new hype, we&#8217;d have those libraries.</p>


	<p>But don&#8217;t kid yourself, we already have our mini <span class="caps">CPAN</span>, some stuff for web, and free stuff is progressing all the time.</p>
</li><li id="comment-85"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_85'); }"  onmouseout="Element.hide('admin_comment_85');" >
  <div id="admin_comment_85" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/85', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-85',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/85" class="admintools">edit</a></div>
  <a name="comment-85"></a>
  
  <cite><strong>Erik Enge</strong> </cite> said about 10 hours later:<br />
  <p>Nice article, though I think zlxcgrogdss (second comment) is spot on with why Ruby is not a Lisp.  Anyways, &#8220;there aren&#8217;t enough libraries&#8221; is being worked on and you can see current progress at http://common-lisp.net/projects.shtml and http://cliki.net/Library for those who might be curious.</p>


	<p>Hope that&#8217;s an ok comment to leave, if not , feel free to pull it.</p>
</li><li id="comment-86"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_86'); }"  onmouseout="Element.hide('admin_comment_86');" >
  <div id="admin_comment_86" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/86', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-86',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/86" class="admintools">edit</a></div>
  <a name="comment-86"></a>
  
  <cite><strong>Dookus Binglebib</strong> </cite> said about 10 hours later:<br />
  <p><i>But don’t kid yourself, we already have our mini <span class="caps">CPAN</span></i></p>


	<p>Wow, already?</p>
</li><li id="comment-87"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_87'); }"  onmouseout="Element.hide('admin_comment_87');" >
  <div id="admin_comment_87" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/87', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-87',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/87" class="admintools">edit</a></div>
  <a name="comment-87"></a>
  
  <cite><strong>eh</strong> </cite> said about 11 hours later:<br />
  <p>try embedding prolog in ruby.</p>
</li><li id="comment-88" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_88'); }"  onmouseout="Element.hide('admin_comment_88');" >
  <div id="admin_comment_88" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/88', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-88',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/88" class="admintools">edit</a></div>
  <a name="comment-88"></a>
  
  <cite><strong>Eric</strong> </cite> said about 11 hours later:<br />
  <p>Anonymous, I agree that <span class="caps">CLOS</span> is a Good Thing.&trade;  In particular, generic functions lead to much cleaner designs than traditional message-passing.  This is a subject <a title="Efficient Compression of Generic Function Dispatch Tables" href="http://www.cs.dartmouth.edu/reports/abstracts/TR2001-404/" rel="nofollow">near and dear</a> to my heart.  You&#8217;re also right to call out Common Lisp&#8217;s condition system.  It&#8217;s an elegant approach to exception-handling, and one that future language designers should study carefully.</p>


	<p>That said, if your Common Lisp style doesn&#8217;t rely heavily on macros, you&#8217;re missing out on half the fun, not to mention your number one sales pitch. :-)</p>
</li><li id="comment-89" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_89'); }"  onmouseout="Element.hide('admin_comment_89');" >
  <div id="admin_comment_89" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/89', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-89',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/89" class="admintools">edit</a></div>
  <a name="comment-89"></a>
  
  <cite><strong>Eric</strong> </cite> said about 11 hours later:<br />
  <p>Null, Dookus, could you please be polite?  Heated arguments are perfectly OK, but please address each other with respect.</p>


	<p>EH, I&#8217;ve been wrestling with the Prolog-in-Ruby problem for a few weeks now.  The backtracking is <a title="McCarthy's Ambiguous Operator" href="http://randomhacks.net/articles/2005/10/11/amb-operator" rel="nofollow">easy</a>, and I&#8217;ve gotten a decent pattern matcher running.  The right-hand side of the rules, though, is proving a little tricky.</p>
</li><li id="comment-90"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_90'); }"  onmouseout="Element.hide('admin_comment_90');" >
  <div id="admin_comment_90" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/90', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-90',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/90" class="admintools">edit</a></div>
  <a name="comment-90"></a>
  
  <cite><strong><a href="http://www.gsnider.com">Garrett Snider</a></strong> </cite> said about 13 hours later:<br />
  <p>Thanks Eric for the article and everyone else for the comments.  I&#8217;ve been coming at Ruby as a long-time Java guy with a now and again interest in <span class="caps">LISP</span> and wandering what the <span class="caps">LISP</span> community thinks of Ruby.  I love it as a step up from Java and I&#8217;ve been thinking that it is reasonably close to <span class="caps">LISP</span>, at least in power (not in language design).  However, I wanted to get a deeper undestanding of the (practical) differences.</p>


	<p>Also, I&#8217;ve taken the pill that allows me to love the &#8220;arbitrary syntax&#8221; mentioned by &#8216;bill a&#8217; above.  I find it hard to convince others who have the <span class="caps">PERL</span> vs. Python dualing philosophies in mind and stand on the Python (/Java) side, but as a way to implement Domain Specific Languages, I think Ruby&#8217;s open syntax shines.  Where I&#8217;ve had a question is on the following issue:</p>


	<p>If the additional syntax options are layered on top of a solid consistant core (like with <span class="caps">LISP</span>), it seems to be solid advantage, perhaps even outshining the venerable <span class="caps">LISP</span> in this respect.  (Specifically, I&#8217;m thinking of Executable DSLs.)  So commentary here regarding the fundamental soundness and consistancy of the Ruby language vs <span class="caps">LISP</span> is especially interesting and appreciated.</p>
</li><li id="comment-91"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_91'); }"  onmouseout="Element.hide('admin_comment_91');" >
  <div id="admin_comment_91" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/91', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-91',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/91" class="admintools">edit</a></div>
  <a name="comment-91"></a>
  
  <cite><strong>bill a</strong> </cite> said about 13 hours later:<br />
  <p>OK, guys&#8230;.you can say whatever you&#8217;d like about Lisp, but please, please, please stop capitalizing it.  It&#8217;s Lisp, not <span class="caps">LISP</span>.</p>
</li><li id="comment-92"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_92'); }"  onmouseout="Element.hide('admin_comment_92');" >
  <div id="admin_comment_92" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/92', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-92',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/92" class="admintools">edit</a></div>
  <a name="comment-92"></a>
  
  <cite><strong>jimmy</strong> </cite> said about 13 hours later:<br />
  <p>Thanks, Bill. That was bugging me too.</p>
</li><li id="comment-93"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_93'); }"  onmouseout="Element.hide('admin_comment_93');" >
  <div id="admin_comment_93" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/93', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-93',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/93" class="admintools">edit</a></div>
  <a name="comment-93"></a>
  
  <cite><strong>Smalltalking with a Lisp</strong> </cite> said about 13 hours later:<br />
  <p>Ruby was inspired mainly by Smalltalk and Lisp.  If you really want your hair blown back, check them out.  Ruby and Python are gateway languages to the above.</p>
</li><li id="comment-94"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_94'); }"  onmouseout="Element.hide('admin_comment_94');" >
  <div id="admin_comment_94" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/94', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-94',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/94" class="admintools">edit</a></div>
  <a name="comment-94"></a>
  
  <cite><strong>bill a</strong> </cite> said about 14 hours later:<br />
  <p>I am curious how much of Ruby comes from Lisp.  I would tend to think that people who are familiar with Lisp do not go around writing languages. :)</p>
</li><li id="comment-95"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_95'); }"  onmouseout="Element.hide('admin_comment_95');" >
  <div id="admin_comment_95" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/95', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-95',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/95" class="admintools">edit</a></div>
  <a name="comment-95"></a>
  
  <cite><strong>Unordinary Programmer</strong> </cite> said about 14 hours later:<br />
  <p>&#8220;Some may say Ruby is a bad rip-off of Lisp or Smalltalk, and I admit that. But it is nicer to ordinary people.&#8221;</p>


	<p>- Matz, <span class="caps">LL2</span></p>
</li><li id="comment-96"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_96'); }"  onmouseout="Element.hide('admin_comment_96');" >
  <div id="admin_comment_96" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/96', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-96',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/96" class="admintools">edit</a></div>
  <a name="comment-96"></a>
  
  <cite><strong>Anonymous Coward</strong> </cite> said about 16 hours later:<br />
  <p>Hmm. Lisp macros are far more powerful than the trivial use cases you&#8217;ve listed. I could give a lot of examples here, but just ask yourself: why is most of the programming community so fond with &#8220;Design Patterns&#8221;, while the Lisp community generally isn&#8217;t?</p>


	<p>Well, that&#8217;s because patterns are nothing but high-level specifications for code being rewritten again and again and again. The Lisp approach is to create some macros and auxiliary functions that actually implement the pattern, thus extending the language capabilities and avoiding continuous reinvention of the wheel.</p>


	<p>It has happened for object orientation (CLOS anyone?), aspect-oriented programming, OO&lt;-&gt;SQL mapping&#8230; All without touching the basic language syntax and implementations.</p>


	<p>Ruby features may compete in some specific cases,  but I bet that the same consideration would apply for other languages too.</p>


	<p>Finally, regarding the Lisp libraries: it&#8217;s true that the language specs are full of historical cruft (e.g. mandatory support for the now-dead versioning filesystems), and lack things like standard sockets. But it&#8217;s also true that there&#8217;s a good amount of free (as in freedom) libraries that fill the gap.  Have a tour on http://cliki.net/ for an appetizer.</p>
</li><li id="comment-97"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_97'); }"  onmouseout="Element.hide('admin_comment_97');" >
  <div id="admin_comment_97" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/97', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-97',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/97" class="admintools">edit</a></div>
  <a name="comment-97"></a>
  
  <cite><strong><a href="http://zifus.blogspot.com">Beowulf</a></strong> </cite> said about 16 hours later:<br />
  <p>I&#8217;ve made a relatively lengthy response to the posts here on my blog.  http://zifus.blogspot.com/2005/12/power-vs-popularity.html</p>


	<p>You may not agree with my reasoning, but realize this is the reasoning process I went through when I decided to build my system in Rails instead of Lisp.  Realize that I love Lisp and I would have used it if I could&#8217;ve focused on solving my actual problems rather than trying to integrate various frameworks together and struggling to get it all working as a cohesive whole.  The biggest reason I abandoned Java and C# is that I wanted to focus on my problem, and not fight with getting the language and framework to do what I want.  This is coming from a lover of Lisp, imagine what someone who either isn&#8217;t a fan of the language or doesn&#8217;t even know it exists is thinking.</p>
</li><li id="comment-98"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_98'); }"  onmouseout="Element.hide('admin_comment_98');" >
  <div id="admin_comment_98" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/98', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-98',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/98" class="admintools">edit</a></div>
  <a name="comment-98"></a>
  
  <cite><strong><a href="http://www.democracynow.org/">Tayssir John Gabbour</a></strong> </cite> said about 20 hours later:<br />
  <p>Ruby&#8217;s creator is outspokenly influenced by Lisp and Smalltalk, yet Ruby&#8217;s success is supposed to be a terrible thing to Lisp users? Particularly since Smalltalk&#8217;s creator also speaks of his influence and admiration of Lisp? ;)</p>


	<p>I (perhaps badly) recall that things in motion tend to have lower friction coefficients. If Ruby&#8217;s technical advantages get the mainstream moving, great.</p>


	<p>I think this is a more reasoned article than I remember seeing from the Java and Python worlds.</p>


	<p>However, I think it has two honest errors. For one thing, I wouldn&#8217;t call Common Lisp a functional language, if by that we mean it is biased towards recursion over other techniques. I use iteration heavily; Lisp&#8217;s <span class="caps">LOOP</span> macro is pretty impressive in this regard, and there are even more powerful 3rd party iteration constructs.</p>


	<p>Perhaps Rubists focus on functions because they correctly find a lot of power in them, but then they&#8217;re viewing Lisp through Ruby-colored glasses.</p>


	<p>Second, as for plain macros, these are just functions which (at some time like &#8220;compiletime&#8221;) take code and return code. They take a sexp and return a sexp.</p>


	<p>What&#8217;s the purpose? Usually expressiveness. Readability.</p>


	<p>Since they can use other aspects of the language like dynamic scope, they multiply the expressive power of the language. But they must be used tastefully, as power requires justification.</p>


	<p>Since I don&#8217;t write lambdas much in the first place, my macro usage certainly ain&#8217;t to save effort typing lambda. ;) Completely orthogonal concepts.</p>
</li><li id="comment-100"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_100'); }"  onmouseout="Element.hide('admin_comment_100');" >
  <div id="admin_comment_100" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/100', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-100',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/100" class="admintools">edit</a></div>
  <a name="comment-100"></a>
  
  <cite><strong>Anonymous (again)</strong> </cite> said about 21 hours later:<br />
  <p>From Eric:
<i>That said, if your Common Lisp style doesn’t rely heavily on macros, you’re missing out on half the fun, not to mention your number one sales pitch.</i></p>


	<p>Ok, I agree with that; my initial response may have been a little rash :-)
My point remains, though, I&#8217;d say that more of half of the fun comes from all the other parts often not mentioned. Macros <em>are</em> an essential part, but just one of many.</p>


	<p>To Beowulf: It sounds to me like you are playing the bitter ex-martyr yourself (no offense intended) there. 
Multiple commercial Lisp vendors are doing just fine, even though their implementations are <em>not</em> cheap and even though there are various actively developed high-quality open-source implementations. That alone shows that the market exists. As David Thornley put it, &#8220;Lisp doesn&#8217;t look any deader than usual to me&#8221;, and all the people saying it the opposite won&#8217;t change that (funny, back when I used FreeBSD, &#8220;FreeBSD is dead&#8221; was the typical (periodically occuring) outcry of many not-users. I guess it&#8217;s not particular to Lisp after all). 
I agree that it isn&#8217;t as widely used for open-source software as many contemporary languages are, but it is used surprisingly often once you look further; in particular, the harder the problems you&#8217;re solving, the more it seems to be used.
The nature of most free Lisp implementations tends to favour long-running programs (they don&#8217;t focus on small initial memory footprints or delivering small binaries), and the benefits of the language help you more the harder your problems get&#8212;abstractions scale (in dealing with the complexity of your program), syntactic shortcuts don&#8217;t. I suspect that this is also why most/many Lispers don&#8217;t care too much about getting a shorter syntax for (lambda (...) ...): It simply doesn&#8217;t win you much (in terms of shorter code size) in non-trivial programs; other factors become much, much more important. (This is also why micro-benchmarks are usually not representative unless you write fibonacci or factorial programs all day)</p>


	<p><i>You must occupy a niche if you will</i> [...]</p>


	<p>No, (in my humble opinion) the whole power of Common Lisp  comes exactly from the fact that it <em>doesn&#8217;t</em> focus on niches. It focuses on power. If you want to occupy a niche, you can easily extend Common Lisp to do that (I think it&#8217;s called &#8220;writing your own <span class="caps">DSL</span>&#8221; nowadays :-); Prolog-in-Lisp, Lisa, AllegroCache and AspectL are just a few examples of that (all implemented as normal libraries, <span class="caps">IIRC</span>). I&#8217;m certain that Common Lisp couldn&#8217;t have survived for this long weren&#8217;t it so extensible: Perl, Python, Java, they and most other new languages all reinvent themselves every other year, and I&#8217;m sure they would have been succeeded by &#8220;competing&#8221; languages by now if they didn&#8217;t &mdash; most niches are moving targets and the competition doesn&#8217;t sleep. The Common Lisp <em>standard</em>, in comparison, has not changed for a long time and probably won&#8217;t (need to) anytime soon.
Sure, that means that writing a simple webpage in <span class="caps">PHP</span> may be simpler; Perl is certainly more comfortable to use for a quick one-liner; Erlang should beat Common Lisp easily in the domain Erlang was created for, and so on. Where Common Lisp shines, however, is when your problem is <em>not</em> covered by a typical niche. It shines when your problem is hard and your requirements aren&#8217;t simple, when you actually can make use of the advanced features. If another language has a library/framework that does just what you want to do, and Common Lisp doesn&#8217;t, why use Common Lisp, anyway?
I think using one language for everything is usually a bad sign (lack of flexibility on part of the developer), not a good one (<em>no</em> language is best at everything, and I never understood people who think that. Also, life would be terribly boring if that were so).
It&#8217;s simply not true that people didn&#8217;t/don&#8217;t write frameworks in Common Lisp, but I suspect that what you consider a framework is usually just called a library in Common Lisp. If you think it is dead in the commercial world, franz.com (one commercial Lisp vendor) alone has more than enough success stories/impressive products to prove that wrong (I guess Lord of the Rings (the movie), Jak and Dexter and Orbitz are typical modern examples). cliki.net / lispwire.com have plenty of links to open-source libraries/software.</p>


	<p>I&#8217;ll close with a quote from Kent Pitman:
&#8220;…Please don&#8217;t assume Lisp is only useful for Animation and Graphics, AI, Bioinformatics, <span class="caps">B2B</span> and E-Commerce, Data Mining, <span class="caps">EDA</span>/Semiconductor applications, Expert Systems, Finance, Intelligent Agents, Knowledge Management, Mechanical <span class="caps">CAD</span>, Modeling and Simulation, Natural Language, Optimization, Research, Risk Analysis, Scheduling, Telecom, and Web Authoring just because these are the only things they happened to list.&#8221;</p>
</li><li id="comment-101" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_101'); }"  onmouseout="Element.hide('admin_comment_101');" >
  <div id="admin_comment_101" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/101', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-101',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/101" class="admintools">edit</a></div>
  <a name="comment-101"></a>
  
  <cite><strong>Eric</strong> </cite> said about 22 hours later:<br />
  <p>Bill, the lowercase spelling &#8220;Lisp&#8221; is certainly correct for Common Lisp (and I&#8217;ve fixed it in the main article&mdash;thanks!).  The uppercase spelling, however, has a <a href="http://www.amazon.com/gp/product/0262130114/103-8183871-7371824?v=glance&#38;n=283155" rel="nofollow">long and respectable history</a>.  The new way certainly <em>is</em> easier on the eyes, but my <span class="caps">LISP</span> teachers were a bit old-school, and I haven&#8217;t overcome my nostalgia yet. :-)</p>


	<p>As for your query about how often <span class="caps">LISP</span> hackers write new languages: Oddly enough, it&#8217;s a <a href="http://www.gwydiondylan.org/" rel="nofollow">bit</a> <a href="http://www.schemers.org/" rel="nofollow">of</a> <a href="http://people.csail.mit.edu/jrb/goo/index.htm" rel="nofollow">an</a> <a href="http://en.wikipedia.org/wiki/Logo_programming_language" rel="nofollow">obsession</a>.  Yeah, I know, it makes no sense.  But <em>H. sapiens</em> always did tend to mess with perfection.</p>


	<p>Tayssir, I would be delighted if Ruby encouraged programmers to take a good look at <span class="caps">LISP</span> (and SmallTalk).  And Ruby is certainly good news for metaprogramming in general.  Maybe we&#8217;ll finally stop hearing about macros being &#8220;too powerful,&#8221; a personal peeve of mine.</p>
</li><li id="comment-103"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_103'); }"  onmouseout="Element.hide('admin_comment_103');" >
  <div id="admin_comment_103" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/103', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-103',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/103" class="admintools">edit</a></div>
  <a name="comment-103"></a>
  
  <cite><strong>Ben</strong> </cite> said 1 day later:<br />
  <p>Nice article.  I&#8217;m not a Ruby user but I will say one language feature it has which Common Lisp doesn&#8217;t&#8212;first class continuations.</p>


	<p>Also, given the success which Python has had in porting to the <span class="caps">CLR</span>, has anyone seriously thought about making a Lisp-like language for .Net?  I mean, there are some things out there, but they seem either not well supported or rather ML-like (which is fine but not exactly like Lisp.)</p>
</li><li id="comment-104"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_104'); }"  onmouseout="Element.hide('admin_comment_104');" >
  <div id="admin_comment_104" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/104', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-104',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/104" class="admintools">edit</a></div>
  <a name="comment-104"></a>
  
  <cite><strong><a href="http://null">Joku</a></strong> </cite> said 1 day later:<br />
  <p>The article didn&#8217;t really compare how things could be done in Python, even though it started from the premise that Ruby might be more powerful. Not really a surprise though, because it would&#8217;ve turned out that Python code can be nearly identical in complexity to Ruby code (sometimes slightly more complex, sometimes slightly less). And neither Ruby nor Python come close to providing the same power as macros in Lisps.</p>


	<p>I don&#8217;t think you gave any reason to consider Ruby over Python.</p>
</li><li id="comment-105"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_105'); }"  onmouseout="Element.hide('admin_comment_105');" >
  <div id="admin_comment_105" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/105', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-105',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/105" class="admintools">edit</a></div>
  <a name="comment-105"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Eric,</p>


	<p>Sure, many years ago &#8220;LISP&#8221; was the correct rendition, but I don&#8217;t think that&#8217;s been the case for quite some time.</p>


	<p>Incidentally, all of those examples you pointed out (Dylan, Scheme, Goo, Logo) are  all dialects of Lisp.  :-)</p>
</li><li id="comment-106"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_106'); }"  onmouseout="Element.hide('admin_comment_106');" >
  <div id="admin_comment_106" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/106', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-106',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/106" class="admintools">edit</a></div>
  <a name="comment-106"></a>
  
  <cite><strong>Anonymous Coward</strong> </cite> said 1 day later:<br />
  <p>About continuations in Lisp: here&#8217;s an example of a language extensions provided by using macros.</p>


	<p>Maybe Common Lisp doesn&#8217;t have &#8220;native&#8221; continuations because they can be created in several ways.  See &#8220;On Lisp&#8221; by Paul Graham for an example (the book is downloadable from his website, if you don&#8217;t want to spend money).</p>


	<p>Maybe they are not syntactically as nice as the Scheme built-in continuations, but for practical pourposes they are just &#8220;good enough&#8221;. And more syntactic sugar is always available by using some macro magic.</p>
</li><li id="comment-107"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_107'); }"  onmouseout="Element.hide('admin_comment_107');" >
  <div id="admin_comment_107" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/107', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-107',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/107" class="admintools">edit</a></div>
  <a name="comment-107"></a>
  
  <cite><strong>First Rest</strong> </cite> said 1 day later:<br />
  <p>This article sounds like it was written for folks who really want to use Lisp, but have chosen Ruby because all the cool kids are using it and want to reasonably justify an emotional decision.</p>


	<p>Lisp has been around a long time and has watched other, more popular languages attempt to catch up to it.  Here&#8217;s a clue:  they still haven&#8217;t.  Figuring that out involves a difficult learning process that challenges most of the things you have learned and involves looking at things in an entirely new way.  If you want to learn a language that can change with the times and incorporate whatever latest fad the programming cool kids have to offer, Lisp is the choice.  Lisp is the red pill.</p>


	<p>One question to ask one of the other commenters (who put his comments on a blog that doesn&#8217;t allow anonymous posting) that mentioned the small Lisp community:  If everyone does like you did and decide to move on, how would the community ever grow?  Low hanging fruit is so much easier to pick.</p>
</li><li id="comment-108"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_108'); }"  onmouseout="Element.hide('admin_comment_108');" >
  <div id="admin_comment_108" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/108', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-108',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/108" class="admintools">edit</a></div>
  <a name="comment-108"></a>
  
  <cite><strong>Lisp + Python = Lython</strong> </cite> said 1 day later:<br />
  <p>What about a sexpr-based language built on top of Python, that generates Python bytecode, can access Python libraries and even supports macros?</p>


	<p>http://lemonodor.com/archives/000648.html</p>


	<p>(Ok, it&#8217;s just a prototype, but here&#8217;s my 2c about the Ruby vs Python vs Lisp issue).</p>
</li><li id="comment-109" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_109'); }"  onmouseout="Element.hide('admin_comment_109');" >
  <div id="admin_comment_109" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/109', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-109',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/109" class="admintools">edit</a></div>
  <a name="comment-109"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>It&#8217;s true, Joku, that Python metaprogramming has become <a title="Django" href="http://www.djangoproject.com/documentation/overview/" rel="nofollow">more common recently</a>, using techniques very similar to those popular in the Ruby world.  This is a good thing, and deserves broader notice.</p>


	<p>Guido, however, has never been much a fan of functional programming, and has <a title="Python Regrets" href="http://www.python.org/doc/essays/ppt/regrets/PythonRegrets.pdf" rel="nofollow">stated</a> (PDF, page 4) that he doesn&#8217;t like lambda, map, filter, reduce, and similar constructs.  Normally, this isn&#8217;t a problem, because Python has slick list comprehensions:</p>


<pre>
[ n*n for n in [1,2,3] if (n*n)%3!=1 ]
</pre>

	<p>In a lot of common cases, list comprehensions will look better than either the Ruby or <span class="caps">LISP</span> examples above.  But there&#8217;s an underlying problem: List comprehensions are a special-purpose feature, and I can&#8217;t use the same mechanisms for building my <em>own</em> domain languages.   And since Python&#8217;s lambda is very limited, it generally won&#8217;t help much.</p>


	<p>Effectively, Python allows me to create new kinds of definitions (by hacking metaclasses), but it doesn&#8217;t allow me to define new control constructs.  Normally, this doesn&#8217;t matter much, but it&#8217;s a nuisance if you&#8217;re trying to build something like <a href="http://www.martinfowler.com/articles/rake.html" rel="nofollow">Rake</a>.</p>
</li><li id="comment-110"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_110'); }"  onmouseout="Element.hide('admin_comment_110');" >
  <div id="admin_comment_110" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/110', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-110',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/110" class="admintools">edit</a></div>
  <a name="comment-110"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>One big difference between Lisp and Ruby is that Ruby gets its dynamicity and its metaprogramming capabilities by doing a lot of code evaluation at runtime.  To people who aren&#8217;t familiar with Lisp, it might seem that this is the only way to do it.</p>


	<p>So for instance in Lisp, I might write a macro to define part of a domain-specific language.  That macro is then expanded into other code at compile-time, and that&#8217;s all there is to it.  Ruby, on the other hand, takes a much more runtime-centric approach; instead of transforming code, I just have to make sure that a given block is evaluated in a context where the methods it calls can be accessed.  So Ruby can&#8217;t make many assumptions about code it reads until that code is actually running.</p>


	<p>The two approaches have advantages and disadvantages, but I (of course ;-) find Lisp&#8217;s approach cleaner.  It means that the compiler can warn about calling undefined functions, and that development environments can easily do things like locate code definitions.  With Ruby&#8217;s approach, in general the semantics of any given snippet of code can only be determined at runtime.  To be sure, Lisp does have an eval function, but it doesn&#8217;t get used much at all outside of Lisp itself.  This is a good thing.  When I was using Ruby, I was sometimes frustrated about this situation &#8211; that all decisions about code are made at the last possible minute.  Of course, this lets you do things like method_missing and so on, but I have yet to miss that (no pun intended) since switching to Lisp.  I don&#8217;t mean to suggest that everything in Lisp must be statically prepared (as in C or Java), only that in general Lisp takes a different approach to dynamicity.</p>


	<p>Just another point to keep in mind.</p>
</li><li id="comment-111" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_111'); }"  onmouseout="Element.hide('admin_comment_111');" >
  <div id="admin_comment_111" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/111', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-111',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/111" class="admintools">edit</a></div>
  <a name="comment-111"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Sweet! Lython&#8217;s definitely a slick hack, and&mdash;judging from the sample code&mdash;the author noticed that Python&#8217;s bytecode is actually more <span class="caps">LISP</span>-like than its official syntax.  Python&#8217;s <code>if</code> statement really is an expression; the parser just refuses to nest it.  In general, the <a href="http://docs.python.org/lib/language.html" rel="nofollow">Python Language Services</a> are a pretty promising framework for implementing a macro system; somebody just needs to roll up their sleeves and make it happen.</p>


	<p>Bill, you&#8217;re absolutely right about <span class="caps">LISP</span> and compile-time versus runtime performance.  Exhibit A: Ruby on Rails takes a couple of seconds to launch a new server process.  With a good compiler, <span class="caps">LISP</span> could do the same thing as fast as the OS could read pages into memory.</p>


	<p>The long-term trends probably favor the <span class="caps">LISP</span> (or even <a title="Hygienic macros" href="http://randomhacks.net/articles/2002/09/13/hygienic-macros" rel="nofollow">Scheme</a>) approach, mostly for reasons of <span class="caps">IDE</span> support and better compile-time checking.  The Ruby approach is actually dangerous if your team doesn&#8217;t maintain unit tests.</p>
</li><li id="comment-112"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_112'); }"  onmouseout="Element.hide('admin_comment_112');" >
  <div id="admin_comment_112" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/112', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-112',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/112" class="admintools">edit</a></div>
  <a name="comment-112"></a>
  
  <cite><strong><a href="http://zifus.blogspot.com">Beowulf</a></strong> </cite> said 1 day later:<br />
  <p>First Rest, I enabled anonymous comments, I didn&#8217;t realize you had to turn that on. :(</p>


	<p>I agree with you that Low hanging fruit is easier to pick, which was exactly why I chose Rails for my system.  That doesn&#8217;t mean I&#8217;ve moved on though, rather it means for this system at this time, I didn&#8217;t feel like Lisp was the right choice.</p>


	<p>As someone else mentioned, increasing popularity of Ruby is a good thing for Lisp.  Anything that gets people looking at languages more powerful than the Java/C/C++ paradigm is a good thing for Lisp.</p>


	<p>Eric, my point wasn&#8217;t that Lisp should become a niche language.  Although in most people&#8217;s mind Lisp already <strong>is</strong> a niche language, it&#8217;s the AI language to them.  I was suggesting that Lisp needs to find a new place to occupy in people&#8217;s minds in order to increase in popularity.  The best way to do that imho is to create a shiny new object (ala Rails) for people to play with and promote the heck out of it.</p>


	<p>Lol, nice retort with the bitter ex-martyr.  It made me laugh if nothing else. :-p.</p>


	<p>I&#8217;ve followed and have been involved in numerous Lisp is better than language &#8220;x&#8221; discussions.  Everyone that I have seen devolves into the all too familiar battle of syntax.  I just think that people won&#8217;t switch languages because the solution to summing children is better in Lisp.  I think that misses the point entirely.  People are after real world, tangible benefits.  Little 3 and 5 line snippets of code simply do not show the actual power and expressiveness of Lisp.  Most people cannot extrapolate a 3 line snippet into a real system.</p>


	<p>I think there is great news that Rails is what is driving adoption of Ruby.  It serves to illustrate that people can and will pick up a new language, even an obscure one with relatively wonky syntax.</p>
</li><li id="comment-113"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_113'); }"  onmouseout="Element.hide('admin_comment_113');" >
  <div id="admin_comment_113" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/113', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-113',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/113" class="admintools">edit</a></div>
  <a name="comment-113"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Beowulf, I don&#8217;t think I ever said the solution to summing children was a reason to switch to Lisp.  I was countering Eric&#8217;s assertion that Ruby is more &#8220;functional&#8221; and &#8220;functionally dense&#8221; than Lisp.  Of course it &#8220;misses the point entirely&#8221; if that&#8217;s how you&#8217;re going to interpret it.</p>


	<p>Real-word, tangible benefits?  OK, here you are:</p>


	<p>- macros give you the power to increase the readablility, concision, and correctness of code.  Consider the <span class="caps">LOOP</span> and <span class="caps">ITERATE</span> macros.  Common patterns of looping are expressed with <em>amazing</em> simplicity simply because <span class="caps">LOOP</span> and <span class="caps">ITERATE</span> can perform code transformations.  For instance, let&#8217;s say you want to loop over the elements in a sequence and return the one with the highest absolute value:</p>


	<pre><code>(iter (for x in seq)
      (finding x maximizing (abs x)))</code></pre>


	<p>I think that&#8217;s fancy.  And when you consider that the <span class="caps">ITER</span> form is going to expand into wicked-fast code at compile-time (and then be compiled to machine code, in some <span class="caps">LISP</span> implementations), you realize that you&#8217;ve just gotten a powerful abstraction and increased readability <strong>for free</strong>.  No runtime efficiency or spacecompletely is wasted with this construct, because <span class="caps">ITERATE</span> has efficient idioms to transform common looping patterns into damn fast code.  Directly using the faster code would mean a huge loss in readability and maintainability &#8211; with Lisp macros, I don&#8217;t have to worry about it.  For the curious, the macroexpansion for that <span class="caps">ITER</span> form is at the bottom of this common.</p>


	<p>For more macros, take a look at Peter Seibel&#8217;s book Practical Common Lisp ( available free at http://www.gigamonkeys.com/book).  In one of the final chapters he builds a binary file parsing system that&#8217;s plain amazing &#8211; and he does it with macros.  Earlier in the book, he writes a test framework in something like 26 lines &#8211; using macros too.  Here is a sample of the code used to parse <span class="caps">ID3</span> tags in <span class="caps">MP3</span>&#8217;s:</p>


	<pre><code>(define-tagged-binary-class id3-tag ()
  ((identifier     (iso-8859-1-string :length 3))
   (major-version  u1)
   (revision       u1)
   (flags          u1)
   (size           id3-tag-size))
  (:dispatch 
    (ecase major-version
     (2 'id3v2.2-tag)
     (3 'id3v2.3-tag))))</code></pre>


	<p>It specifices the types and order of the data to be read from the file, and then passes control to another binary-class based on the value of major-version &#8211; and even automatically throws an error if the major-version is invalid.</p>


	<p>- interactive development.  If you haven&#8217;t used this, you&#8217;re missing out.  Most languages are about writing lines of code, feeding them to either an interpreter or a compiler, and then watching what happens.  In Lisp, development is always done live and interactively.  You write functions in files and then send them to a Lisp image.  You develop each component of your system one by one and test it live.  There is no compile-run-debug cycle &#8211; there isn&#8217;t even an interpret-debug cycle.  It&#8217;s more like a write-test cycle.</p>


	<p>Interactive development also means you have access to your running system.  Not sure what parameters a fucntion takes?  Start typing &#8220;(func &#8221; and the Lisp environment will remind you what arguments can legally follow that.  Want information on an object you&#8217;re playing with?  Type &#8220;(inspect x)&#8221; and an interactive, recursive inspector will let you walk through it, even making changes as you go.</p>


	<p>Once you get your program working, you refactor a little, do some benchmarks, take advantage of Lisp&#8217;s completely optional type system to speed up bottlenecks, and sit back and admire your work.</p>


	<p>- the condition/restart system.  In most languages, there is not much that can be done after an exception is raised.  Log it, send it to the user, end the program.  In Lisp, an error can be <em>restarted</em>.  For instance, in the UncommonWeb framework, when you browse to a <span class="caps">URL</span> and an error is signaled, you get the backtrace in your environment.  You can now make changes to your code, recompile it, and then invoke the <span class="caps">RESTART</span>-REQUEST restart.  <span class="caps">UCW</span> starts processing your request from the beginning, and the browser gets the result of running your latest, changed code.</p>


	<p>- regular syntax.  In Lisp, all forms can be broken down into (operator [args]).  There is nothing else.  This means that I can write macros, but it also means that editors can do really neat things with code, because Lisp is regular.  I can move up, down, forward, backward, into, and out of lists with Emacs keychords.  This might be difficult to appreciate until you&#8217;ve tried it, but I really recommend it.  Refactoring code becomes trivial when you can treat control structures as a single entity and cut and paste them.</p>


	<p>- almost 50 years of use and development.  Lisp has survived longer than every language except <span class="caps">FORTRAN</span>.  It survived C, C++, Ada, <span class="caps">COBOL</span>, and it will survive Java and Ruby.  It is, to borrow Paul Graham&#8217;s term, &#8220;the hundred-year language.&#8221;</p>


	<p>- more!</p>


	<p>All of this said, I ought to admit that I do use Ruby and Rails in all of my professional projects.  This is not because I don&#8217;t think Lisp is ready, but simply because I hadn&#8217;t learned Lisp when I started these projects.  I now regret that, and my next web application will be in Lisp.</p>


	<p>As promised, here is the crazy but efficient expansion of the <span class="caps">ITERATE</span> form above:</p>


	<pre><code>(LET* ((#:LIST6 NIL)
      (X NIL)
      (#:TEMP7 NIL)
      (#:RESULT5 NIL)
      (#:MAX8 NIL)
      (#:FIRST-TIME9 T))
 (BLOCK NIL
   (TAGBODY
     (SETQ #:LIST6 SEQ)
    LOOP-TOP-NIL
     (IF (ATOM #:LIST6) (GO LOOP-END-NIL))
     (SETQ X (CAR #:LIST6))
     (SETQ #:LIST6 (CDR #:LIST6))
     (SETQ #:TEMP7 (SQRT X))
     (COND
      (#:FIRST-TIME9 (SETQ #:FIRST-TIME9 NIL)
                     (SETQ #:MAX8 #:TEMP7)
                     (SETQ #:RESULT5 X))
      (T
       (COND ([snipped to prevent
               overflow -ed.])
             (T #:RESULT5))))
     (GO LOOP-TOP-NIL)
    LOOP-END-NIL)
   #:RESULT5))</code></pre>


	<p>- Bill (who is heartily enjoying this discussion)</p>
</li><li id="comment-115"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_115'); }"  onmouseout="Element.hide('admin_comment_115');" >
  <div id="admin_comment_115" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/115', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-115',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/115" class="admintools">edit</a></div>
  <a name="comment-115"></a>
  
  <cite><strong>Johnny</strong> </cite> said 1 day later:<br />
  <p>Ruby is more than just a dynamic or scripting language. But feel free to snob it. More &#8220;Rails-like&#8221; projects are on the way.</p>
</li><li id="comment-116"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_116'); }"  onmouseout="Element.hide('admin_comment_116');" >
  <div id="admin_comment_116" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/116', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-116',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/116" class="admintools">edit</a></div>
  <a name="comment-116"></a>
  
  <cite><strong>First Rest</strong> </cite> said 1 day later:<br />
  <p>Lisp lets <span class="caps">YOU</span> be Gosling or Matz or Guido. If you want to extend the language, it&#8217;s possible:</p>


	<p>&#8220;DOLIST is similar to Perl&#8217;s foreach or Python&#8217;s for. Java added a similar kind of loop construct with the &#8220;enhanced&#8221; for loop in Java 1.5, as part of <span class="caps">JSR</span>-201. Notice what a difference macros make. A Lisp programmer who notices a common pattern in their code can write a macro to give themselves a source-level abstraction of that pattern. A Java programmer who notices the same pattern has to convince Sun that this particular abstraction is worth adding to the language. Then Sun has to publish a <span class="caps">JSR</span> and convene an industry-wide &#8220;expert group&#8221; to hash everything out. That process-<del>according to Sun</del>-takes an average of 18 months. After that, the compiler writers all have to go upgrade their compilers to support the new feature. And even once the Java programmer&#8217;s favorite compiler supports the new version of Java, they probably still can&#8217;t use the new feature until they&#8217;re allowed to break source compatibility with older versions of Java. So an annoyance that Common Lisp programmers can resolve for themselves within five minutes plagues Java programmers for years.&#8221;</p>


	<p>&#8212;Peter Siebel from Practial Common Lisp</p>
</li><li id="comment-117"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_117'); }"  onmouseout="Element.hide('admin_comment_117');" >
  <div id="admin_comment_117" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/117', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-117',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/117" class="admintools">edit</a></div>
  <a name="comment-117"></a>
  
  <cite><strong>Garrett</strong> </cite> said 1 day later:<br />
  <p>Thanks Bill. That&#8217;s very helpful stuff.</p>
</li><li id="comment-118"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_118'); }"  onmouseout="Element.hide('admin_comment_118');" >
  <div id="admin_comment_118" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/118', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-118',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/118" class="admintools">edit</a></div>
  <a name="comment-118"></a>
  
  <cite><strong><a href="http://null">null</a></strong> </cite> said 1 day later:<br />
  <p>Some things not mentioned: meta-object protocol; sexpr (code is data, data is code); for commercial lisps, amazing IDEs.</p>


	<p>Schemes also have advantages: smaller language &#8211; philosophy is move the rest of code to libraries; free near-C fast compilers (Bigloo) (free Schemes have better IDEs than Lisp); possibility prototype algorithms with call/cc and finally translating to efficient iterative algorithms in imperative languages (like C).</p>


	<p>A final example: look at the 2 open source Computer Algebra Systems written in Common Lisp available as Open Source: 1) Axiom &#8211; originally from <span class="caps">IBM</span> Thomas Watson Research Center; 2) Maxima &#8211; originally Department of Energy (US).
This is software written in the 70s. You can&#8217;t write software that lasts so long with a language that is a moving target. This is the kind of survival and complex domain which shows the power of Lisp.</p>


	<p>All these scripting languages are really about people experimenting with language syntax. This is nice, but look at it for what it is. Additionally, almost none of those languages have any theory attached to them. Lisp has (lambda calculus), Smalltalk has (Actors), ML has (type theory). This garantees good, lasting design. Take a look at Perl6 for an example of extreme design experiment. Where it&#8217;s going, nobody knows, but &#8211; hey! &#8211; they&#8217;re using Haskell in the implementation (I always thought Perl people were smart).</p>


	<p>Lisp was very expensive and demanding of hardware in the 70s and 80s. This is not so anymore. There is no great shiny free Lisp <span class="caps">IDE</span> (yet), but at least one vendor sells a good one for a relatively good price. Surely, this can&#8217;t keep people from using lisp, since people have taken to relatively &#8220;rough&#8221; stuff like Perl. By the way, there&#8217;s a great Perl book called Higher Order Perl that is really about learning a lot of techniques from Lisp and applying to Perl. I bet a lot of them could be applied to Ruby.</p>


	<p>All these scripting languages do is create a problem and sell you a solution. But to be fair, scripting languages empowered programmers like Lisp had not (&#8220;batteries included&#8221;, etc).</p>


	<p>I think <strong>the</strong> problem with Common Lisp and Smalltalk is the <strong>size</strong> of the stuff you have to learn, syntax-wise. Some jobs that required scripting languages in the 90s required learning something fast (everything is more complex nowadays &#8211; but at least you&#8217;ve got frameworks). Also, Perl, Python, etc, were very portable. Syntax-wise, however, I think the approach taken by Scheme and Eiffel are more sensible (there are reasons for the size of Common Lisp as well as Smalltalk &#8211; but I believe it is an impediment).</p>


	<p>Who knows, maybe people will try Lisp because of Ruby. I bet more people will get frustrated than contribute back. Also try Scheme. It&#8217;s a different philosophy and gets even less press than Common Lisp, but it&#8217;s worth it.</p>
</li><li id="comment-119"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_119'); }"  onmouseout="Element.hide('admin_comment_119');" >
  <div id="admin_comment_119" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/119', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-119',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/119" class="admintools">edit</a></div>
  <a name="comment-119"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Boy I wish there was a comment editing facility here.  More typos:</p>


	<p>&#8220;the bottom of this comment&#8221; &#8211; not &#8220;the bottom of this common&#8221; 
an extra &#8220;completely&#8221; in &#8220;no extra space or time is wasted&#8221; 
&#8220;even allowing you to make changes&#8217; instead of &#8220;making changes as you go&#8221;</p>


	<p>Also, a clearer version of the iterate example would be: </p>


	<pre><code>(iter (for x in '(-1 2 -10 4))
      (finding x maximizing (abs x)))</code></pre>


	<pre><code>;; =&gt; -10</code></pre>


	<p>Sorry, guys.  I guess these don&#8217;t make too much difference, but hopefully this comment will clear up some confusion.</p>
</li><li id="comment-120"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_120'); }"  onmouseout="Element.hide('admin_comment_120');" >
  <div id="admin_comment_120" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/120', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-120',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/120" class="admintools">edit</a></div>
  <a name="comment-120"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>null, that&#8217;s good advice but those not familiar with Scheme should remember that Common Lisp and Scheme are very different languages.  The superficial similarities in their syntax don&#8217;t make that obvious, and so some people perceive them as pretty much interchangeable.  I personally do not care for Scheme, and yet Common Lisp is by far my favorite language.  So if you&#8217;ve had exposure to Scheme and didn&#8217;t like it, don&#8217;t dismiss Common Lisp out of hand (and vice-versa, too).</p>


	<p>I agree that it does take a lot of work and mind-warping to &#8220;get&#8221; Lisp and I also agree that that&#8217;s probably helped to hold it back.  I think Peter Seibel&#8217;s book Practical Common Lisp (I cannot recommend this book strongly enough!) goes a long way to resolving that.</p>
</li><li id="comment-121"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_121'); }"  onmouseout="Element.hide('admin_comment_121');" >
  <div id="admin_comment_121" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/121', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-121',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/121" class="admintools">edit</a></div>
  <a name="comment-121"></a>
  
  <cite><strong>Johnny</strong> </cite> said 1 day later:<br />
  <p>You remember what the Japanese car companies did to GM? :-) Big, powerful, shiny, etc, aren&#8217;t enough to match simplicity and hardwork. Lisp people ignore 90% of the Ruby features.</p>
</li><li id="comment-122"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_122'); }"  onmouseout="Element.hide('admin_comment_122');" >
  <div id="admin_comment_122" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/122', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-122',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/122" class="admintools">edit</a></div>
  <a name="comment-122"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Sigh.  Johnny, have you even read the discussion?  Do you know what&#8217;s being discussed, or are you just making emotionally-driven, knee-jerk reactions because the superiority of your favorite language is being called into quexstion?  Lisp people are aware of all of Ruby&#8217;s features because many of them come from Lisp.  No one here is attacking Ruby (at least I&#8217;m not).  The point of the discussion is simply that Lisp is awesome.  Ruby&#8217;s geography has nothing to do with its properties as a language, and many of the concepts in Lisp are actually, believe it or not, much simpler than Ruby&#8217;s.  It&#8217;s really not intelligent to make claims about the Lisp community, especially when you quite plainly don&#8217;t know Lisp.  Also, what exactly is wrong with being a &#8220;dynamic language&#8221;?  You use the term as if it were an insult.  What is Ruby if not a dynamic language?</p>
</li><li id="comment-123"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_123'); }"  onmouseout="Element.hide('admin_comment_123');" >
  <div id="admin_comment_123" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/123', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-123',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/123" class="admintools">edit</a></div>
  <a name="comment-123"></a>
  
  <cite><strong><a href="http://zifus.blogspot.com">Beowulf</a></strong> </cite> said 1 day later:<br />
  <p>Bill, that was a very well written comment.  One definite pain point for me has been the lack of macros.   There is enough similarity in my comment and scoring system in different areas that I really have wanted a better method for abstraction.  Rails has the concept of Partials and Components, which can be used to abstract your design, however they also carry a pretty significant performance overhead.  That overhead has forced me to abandon them on some pages because they simply were to slow with good abstractions in place.  Several good macros on the other hand would have allowed me an elegant level of abstraction without that same type of performance hit.</p>


	<p>Practical Common Lisp (PCL) is definitely an important book for Lisp.  It took me a long time to find a good book to learn Lisp from (this was prior to the release of <span class="caps">PCL</span>), and I finally had to go back to Lisp by Winston and Horn.  A book written in 80&#8217;s which is no longer in print.  In <span class="caps">PCL</span> there is finally a well written introduction to Lisp that is relevant to solving the problems of the Internet age.</p>


	<p>I honestly hope Lisp gets an upsurge in popularity.  Things seem to be moving more and more in the direction of power and expressiveness.  It just appears to be happening at a relatively glacial pace.      
Lisp clearly has the power to stay the course though.</p>


	<p>As Eric mentioned in the original article though, Ruby really is a good next choice.  Paul Graham once said if you can&#8217;t use Lisp, use Python.  I&#8217;ve used Python for a long time now, and I definitely prefer Ruby to Python at this point.  As a language it is much closer to Lisp than Python, and it&#8217;s OO syntax is <strong>much</strong> cleaner.  That being said, it&#8217;s not a bad thing to know all three (Lisp, Ruby, and Python).</p>
</li><li id="comment-124" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_124'); }"  onmouseout="Element.hide('admin_comment_124');" >
  <div id="admin_comment_124" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/124', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-124',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/124" class="admintools">edit</a></div>
  <a name="comment-124"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Johnny, Bill, please keep it polite. We&#8217;re having a good discussion here, and I don&#8217;t want to <a href="http://nielsenhayden.com/makinglight/archives/006871.html" rel="nofollow">take away anyone&#8217;s vowels</a>. :-)</p>


	<p>Bill&#8217;s point is excellent, and deserves elaboration.  I can easily translate his code to Ruby:</p>


<div class="typocode"><pre><code class="typocode_ruby "><span class="keyword">class </span><span class="class">Array</span>
  <span class="keyword">def </span><span class="method">find_maximizing</span>
    <span class="ident">result</span><span class="punct">,</span> <span class="ident">f_result</span> <span class="punct">=</span> <span class="constant">nil</span><span class="punct">,</span> <span class="constant">nil</span>
    <span class="ident">each</span> <span class="keyword">do</span> <span class="punct">|</span><span class="ident">x</span><span class="punct">|</span>
      <span class="ident">f_x</span> <span class="punct">=</span> <span class="keyword">yield</span> <span class="ident">x</span>
      <span class="keyword">if</span> <span class="ident">f_result</span><span class="punct">.</span><span class="ident">nil?</span> <span class="punct">||</span> <span class="ident">f_x</span> <span class="punct">&gt;</span> <span class="ident">f_result</span>
        <span class="ident">result</span><span class="punct">,</span> <span class="ident">f_result</span> <span class="punct">=</span> <span class="ident">x</span><span class="punct">,</span> <span class="ident">f_x</span>
      <span class="keyword">end</span>
    <span class="keyword">end</span>
    <span class="ident">result</span>
  <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="punct">[</span><span class="number">1</span><span class="punct">,</span><span class="number">2</span><span class="punct">,-</span><span class="number">3</span><span class="punct">].</span><span class="ident">find_maximizing</span> <span class="punct">{|</span><span class="ident">x</span><span class="punct">|</span> <span class="ident">x</span><span class="punct">.</span><span class="ident">abs</span> <span class="punct">}</span></code></pre></div>

	<p>But my code is going to run much slower than Bill&#8217;s, because the <code>iter</code> macro lives in the compiler.  The same goes for the IDv3 parser: It would look fine in Ruby, but get absolutely clobbered on performance.</p>


	<p>A year from now, this could actually be a pretty good sales pitch for Common Lisp. &#8220;It&#8217;s like Ruby, but it runs at full hardware speed!&#8221;</p>
</li><li id="comment-125"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_125'); }"  onmouseout="Element.hide('admin_comment_125');" >
  <div id="admin_comment_125" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/125', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-125',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/125" class="admintools">edit</a></div>
  <a name="comment-125"></a>
  
  <cite><strong>Johnny</strong> </cite> said 1 day later:<br />
  <p>Bill, you are one of the few who claim to be proficient at both, Ruby and Lisp. The problem is that the features that you or other people are going to use in Lisp are just a subset of the features that Ruby is used for. For example, Ruby is very suitable for shell programming, instead of Bash, Sed, Awk, Perl, etc. I just recently started using Rake, and it&#8217;s a really awesome tool to use for shell programming. RubyC, mkmf.rb, setup.rb, etc, really make it easy to create extensions for Ruby that bind to external libraries. I don&#8217;t think people enjoy creating bindings for Lisp as much as people do in Ruby.</p>


	<p>So, if all you want to do is to create WebApps in Lisp, fine. But that use is just a subset of what Ruby is normally used for. I know that Lisp is quite powerful as I said that myself. I know it&#8217;s used for tons of different things. But WebApps really are what most people seem to be doing these days. Though with Ruby you can use it for more than just Web site handling.</p>


	<p>So, when I claim people don&#8217;t know most Ruby features, it&#8217;s just because they are spread among many use-cases, libraries, etc, just like in Lisp.</p>


	<p>Code RESTful in Ruby!</p>
</li><li id="comment-126" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_126'); }"  onmouseout="Element.hide('admin_comment_126');" >
  <div id="admin_comment_126" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/126', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-126',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/126" class="admintools">edit</a></div>
  <a name="comment-126"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Null wrote: <i>I think the problem with Common Lisp and Smalltalk is the size of the stuff you have to learn, syntax-wise.</i></p>


	<p>I&#8217;ve taught Scheme to a lot of non-programmers over the years.  The syntax is problematic, but only until they find a good editor.  (Emacs, sadly, doesn&#8217;t work for many non-programmers.)  The other big impediment is usually <span class="caps">LET</span>, which introduces too much nesting for some folks.</p>


	<p>The larger obstacle is learning to <em>think</em> in <span class="caps">LISP</span> (or SmallTalk, or Haskell, or any other powerful language).  Bill can post a dozen excellent macros, and most people will say, &#8220;Huh?&#8221;  Until you know how to use it, it&#8217;s just a weird feature.</p>


	<p>It&#8217;s actually easier to sell a language by solving small problems (my web apps are ugly!) than by proposing profound new features.  Ruby gets in the door because (1) Rails is slick, and (2) the syntax doesn&#8217;t look <em>too</em> odd.  And once people have played with ActiveRecord for a while, they begin to understand why metaprogramming is cool.</p>
</li><li id="comment-127" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_127'); }"  onmouseout="Element.hide('admin_comment_127');" >
  <div id="admin_comment_127" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/127', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-127',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/127" class="admintools">edit</a></div>
  <a name="comment-127"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Johnny, even though few people write Makefiles or shell scripts in Lisp, it&#8217;s <a href="http://www.scsh.net/" title="Scheme Shell" rel="nofollow">certainly possible</a>. Lisp is basically a toolkit for building programs like Rake.</p>


	<p>So why don&#8217;t you see more great Lisp frameworks? Mostly because (until very recently) the Lisp community was small, fragmented, and didn&#8217;t have anything like <span class="caps">CPAN</span> or RubyGems.  Most of the Good Tricks&trade; had been written down only once or twice, and the books had gone out of print.</p>


	<p>Fortunately, a lot of the missing pieces have appeared in the last five years, and many of the rest will be along soon.</p>
</li><li id="comment-128"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_128'); }"  onmouseout="Element.hide('admin_comment_128');" >
  <div id="admin_comment_128" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/128', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-128',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/128" class="admintools">edit</a></div>
  <a name="comment-128"></a>
  
  <cite><strong>timsuth</strong> </cite> said 1 day later:<br />
  <p>Eric: &#8220;def find_maximizing&#8221;</p>


	<p>Ruby 1.9 has &#8220;max_by&#8221;.</p>


<code>
[1, 2, -3].max_by { |x| x.abs }
</li><li id="comment-129"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_129'); }"  onmouseout="Element.hide('admin_comment_129');" >
  <div id="admin_comment_129" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/129', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-129',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/129" class="admintools">edit</a></div>
  <a name="comment-129"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>OK, here&#8217;s another example of <span class="caps">ITERATE</span> that I hope showcases a little more of macros&#8217; sweetness:</p>


	<pre><code>(iter (for x in '(1 2 3 -4 -10 -43 49 49 8934))
         (until (= (sqrt 7) x))
         (collect x into collection)
         (finding x maximizing (abs x) into y)
         (finally (return (list collection y))))
;; ((1 2 3 -4 -10 -43) -43)</code></pre>


	<p>This is a lot more complicated than the other example, and still not really useful, but I hope it illustrates how <span class="caps">ITERATE</span> provides a whole sublanguage for expressing any kind of iteration you can think of.</p>


	<p>I&#8217;d also like to point out that <span class="caps">ITERATE</span> can be extended with user-defined macros.  For instance, I&#8217;ve written a macro called <span class="caps">AVERAGING</span> that works with <span class="caps">ITERATE</span>:</p>


	<pre><code>(defmacro averaging (var)
 "Add a clause to ITERATE to average the value of VAR." 
 (with-unique-names (count total)
   `(progn
      (summing ,var :into ,total)
      (counting ,var :into ,count)
      (finally (return (/ ,total ,count))))))</code></pre>


	<pre><code>(iter (for x in '(1 2 3 4 5))
     (averaging x))   ;; =&gt; 3</code></pre>


	<p>There&#8217;s more Lisping going on here, and some of this probably looks pretty esoteric (incidentally, this example also shows off Lisp&#8217;s docstrings &#8211; that string after the defmacro line will be associated with <span class="caps">AVERAGING</span> as its documentation, so I can run (describe &#8216;averaging) and get that string at runtime).  But notice that I&#8217;m working with an extensible sublanguage for expressing the most common concepts in iteration.  The examples Eric and timsuth gave could be defined in any language with first-class functions, but no language but Lisp could define a custom mini-construct like this.  Note also that even though <span class="caps">ITERATE</span> provides new coding constructs, I still have full access to Lisp within:</p>


	<pre><code>(iter (for x initially 0 then (1+ x))
      (if (evenp x)
         (print x))
      (when (= x 10)
         (return x)))</code></pre>


	<p>In this (contrived) example, everything except the first line is straight Lisp.</p>


	<p>This sort of thing isn&#8217;t possible in Ruby.  Here&#8217;s another example:</p>


	<pre><code>(iter (for line in-file "foobaz" using #'read-line)
       (collect line))</code></pre>


	<p>This will collect every line in file &#8220;foobaz&#8221; into a list.</p>


	<pre><code>(iter (for line in-file "foobaz" using #'read-line)
       (collect line at beginning))</code></pre>


	<p>will collect the lines in reverse by adding each to the beginning of the result instead of the end.</p>


	<pre><code>(iter (for line in-file "foobaz" using #'read-line)
       (collect line at beginning result-type 'vector))</code></pre>


	<p>will collect the lines into a vector instead of a list.</p>


	<p>And so on and so on, ad infinitum (or nauseam, since my comments are starting to get repetitive).  The point is that the authors of <span class="caps">ITERATE</span> have built a mini-language that is:</p>


	<p>1) able to capture the most common iteration constructs, even relatively complex ones, like maximizing a function and collecting items based on some condition</p>


	<p>2) user-extensible</p>


	<p>3) written in Lisp and <em>not</em> part of the Common Lisp language itself &#8211; that is, you or I could sit down and write <span class="caps">ITERATE</span> and no one would know it wasn&#8217;t part of the language</p>


	<p>4) fast, and yet still high-level</p>


	<p>There is much more to macros than just <span class="caps">ITERATE</span>, but I think <span class="caps">ITEREATE</span> is such a good example of the kind of power that regular syntax and macros can give you.  And keep in mind that all this ends up as fast, tight machine code.  And if it still isn&#8217;t fast enough, throw in some type declarations and optimization settings:</p>


	<pre><code>(iter (for x in '(1 2 3 4 5))
       (declare (type fixnum x))
       (declare (optimize (speed 3) (safety 0) (debug 0)
                  (compilation-speed 0)))
       (averaging x))</code></pre>


	<p>I hope that these comments are useful to people who are curious about Lisp.  I wish I&#8217;d known about some of these things many years ago.</p>


	<p>All code untested.</p>


	<p>- Bill</p>


	<p>P.S. While I appreciate Eric&#8217;s request that we keep it civil here, Johnny, saying that Lisp only has a <strong>subset</strong> of Ruby&#8217;s features is outrageous.  It is quite, quite the opposite.</p>
</li><li id="comment-130"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_130'); }"  onmouseout="Element.hide('admin_comment_130');" >
  <div id="admin_comment_130" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/130', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-130',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/130" class="admintools">edit</a></div>
  <a name="comment-130"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>OK, since I&#8217;ve spent the majority of my day commenting here, it is time to go do some other things, but I would like to also call attention to the fact that those optimizations in the last example are local only to the block that contains them &#8211; I think that&#8217;s pretty damn cool.</p>


	<p>And just <strong>one more</strong> example of macros.  AllegroCache is a commercial database for Lisp that lets you make queries in Prolog.  <span class="caps">DISCLAIMER</span>: I do not know Prolog very well, and I remember the examples I&#8217;ve seen very vaguely, so this may not be exactly and completely accurate, but it gives you a rough idea:</p>


	<pre><code>(&lt;-- (parent ?x ?y)
     (db person ?x children ?c)
     (member ?y ?c))</code></pre>


	<pre><code>(&lt;-- (grandparent ?x ?y)
     (parent ?x ?z)
     (parent ?z ?y))</code></pre>


	<p>Here, the &lt;&#8212;macro indicates that the following forms will be in prolog.  What we&#8217;ve done here is define parent and grandparent relations using Prolog.  So we declare roughly how the two relate to each other, and then we can make queries on the database with these.</p>


	<p>So say I have a variable x with myself in it.  I can then run the Prolog query macro, ?-, like so:</p>


	<pre><code>(?- (parent me ?x))</code></pre>


	<p>and AllegroCache will return the name of anyone in the database who has me as a member of their children list.  I could do the same with grandparents.</p>


	<p>Folks, I think this is one of the coolest things I&#8217;ve ever seen.  Again, these are macros, so all the prolog gets reduced to Lisp code at compile-time, but really have you ever seen anything this cool?  Can you picture the hideousness of the <span class="caps">SQL</span> that would do this?</p>


	<p>Lisp owns.</p>


	<p>OK, for real, there are many more things in life than the RandomHacks weblog, and I must go and attend to them.  Hope I&#8217;ve made a difference.</p>
</li><li id="comment-131"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_131'); }"  onmouseout="Element.hide('admin_comment_131');" >
  <div id="admin_comment_131" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/131', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-131',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/131" class="admintools">edit</a></div>
  <a name="comment-131"></a>
  
  <cite><strong>Johnny</strong> </cite> said 1 day later:<br />
  <p>Alright, Bill. Sorry about my &#8220;car&#8221; analogy. Sorry for pretending that Lisp users use a subset of what&#8217;s normally available for Ruby. It&#8217;s just that the world is too polite sometimes. If you use an &#8220;obscure&#8221; language and nobody talks about it, you are guilty of not spreading the world. If you use an &#8220;obscure&#8221; language and people talk about it, you are guilty of &#8220;hyping&#8221; it. It seems that we can only &#8220;hype&#8221; it if we present a revolutionary tool like Rails. Fine. Maybe in the future we will have some more of that. Till then, see you.</p>
</li><li id="comment-132"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_132'); }"  onmouseout="Element.hide('admin_comment_132');" >
  <div id="admin_comment_132" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/132', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-132',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/132" class="admintools">edit</a></div>
  <a name="comment-132"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Nope, there will be one more comment.</p>


	<p>First of all, the Prolog clauses do not actually expand into any serious code &#8211; they expand into calls to AllegroProlog functions and a little bit of bookkeeping.  My bad.  I think I gave the impression that they directly become code that is equivalent to the Prolog.</p>
</li><li id="comment-133"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_133'); }"  onmouseout="Element.hide('admin_comment_133');" >
  <div id="admin_comment_133" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/133', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-133',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/133" class="admintools">edit</a></div>
  <a name="comment-133"></a>
  
  <cite><strong>JAP</strong> </cite> said 1 day later:<br />
  <p>I could start this comment with <strong><span class="caps">LOL</span></strong>, because the proposed statement is showing so perfectly the real deep misunderstanding of many of us regarding Lisp:</p>


	<p>So let me shortly explain my point of view:</p>


	<p>The real reason that brought me to Lisp (and <strong>never</strong> will get me away from it) is simply this:</p>


	<p>You can build it out of 7 (s-e-v-e-n) primitive operators!</p>


	<p>And, as a consequence, no other language can be expressed in itself as short as Lisp.
(As you probably know, quite any language can be expressed in itself.)</p>


	<p>So let me repeat: really no other language can be expressed in itself that short, and (as a natural consequence) can be built out of less primitive operators.</p>


	<p>All the other features of Lisp are only <strong>natural</strong> <strong>consequences</strong> of the above.
Because McCarthy did not &#8220;create&#8221; Lisp (as any other language designer does), he did &#8220;discover&#8221; it!! (If you read this sentence for the first time, please read it another 2 times).</p>


	<p>So the real point is: no other language can be more simple and more flexible than Lisp at the same time. <span class="caps">BASTA</span>!</p>


	<p><span class="caps">JAP</span> (just another Paul [not Graham])</p>


	<p>P.S. For the philosophers of us: we are all together very difficult, and really have a hard time to become more simple for the rest of our lifes ;-)</p>
</li><li id="comment-134"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_134'); }"  onmouseout="Element.hide('admin_comment_134');" >
  <div id="admin_comment_134" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/134', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-134',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/134" class="admintools">edit</a></div>
  <a name="comment-134"></a>
  
  <cite><strong>Johnny</strong> </cite> said 1 day later:<br />
  <p>One last comment: maybe &#8220;Lisp is the most algorithmic language&#8221;.</p>
</li><li id="comment-135"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_135'); }"  onmouseout="Element.hide('admin_comment_135');" >
  <div id="admin_comment_135" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/135', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-135',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/135" class="admintools">edit</a></div>
  <a name="comment-135"></a>
  
  <cite><strong>Haskell Junkie</strong> </cite> said 1 day later:<br />
  <p>Well, macros are fine and dandy, but don&#8217;t let the lisp diehards lead you astray.  Learning the Haskell language will show you how to do all the <span class="caps">DSL</span> and other tricks using just higher order functions.  After putting about 3 months effort into learning Haskell, you&#8217;ll probably come to see most macro usages as unnecessary hacks.  I&#8217;d even bet that someone&#8217;s already done monads in Ruby.  Interesting examples to get you motivated include <a href="http://www.cs.nott.ac.uk/~gmh/bib.html#pearl" rel="nofollow">parser combinators</a> and <a href="http://okmij.org/ftp/Computation/monads.html" rel="nofollow">backtracking</a>.</p>
</li><li id="comment-136"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_136'); }"  onmouseout="Element.hide('admin_comment_136');" >
  <div id="admin_comment_136" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/136', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-136',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/136" class="admintools">edit</a></div>
  <a name="comment-136"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Bill, if you&#8217;re interested in combining Prolog with a Lisp dialect, I&#8217;ve heard that <a href="http://www.amazon.com/gp/product/0262562146/103-8183871-7371824?v=glance&#38;n=283155" rel="nofollow">The Reasoned Schemer</a> is an excellent introduction to logical programming in Scheme.</p>


	<p>Haskell Junkie, thank you for the links to the parser and backtracking papers.  Haskell is often unrepresented in these discussions, which is too bad, because it&#8217;s a powerful and unique language.</p>


	<p>And yes, somebody <em>is</em> working on <a href="http://lambda-the-ultimate.org/node/view/1128" rel="nofollow">monads in Ruby</a>.</p>


	<p>Once again, a big thank you to everyone for having kept this discussion friendly.  Good manners make it <em>easier</em> to have heated, passionate arguments about important stuff. :-)</p>
</li><li id="comment-137"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_137'); }"  onmouseout="Element.hide('admin_comment_137');" >
  <div id="admin_comment_137" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/137', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-137',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/137" class="admintools">edit</a></div>
  <a name="comment-137"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Eric, I&#8217;ve got <span class="caps">PAIP</span> here when I finally get around to learning Prolog in Lisp.  I was mostly just impressed that it could be used to make complex queries on a database.</p>


	<p>Haskell Junkie, can you give some examples?</p>
</li><li id="comment-138"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_138'); }"  onmouseout="Element.hide('admin_comment_138');" >
  <div id="admin_comment_138" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/138', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-138',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/138" class="admintools">edit</a></div>
  <a name="comment-138"></a>
  
  <cite><strong>SB</strong> </cite> said 1 day later:<br />
  <p>&#8220;So let me repeat: really no other language can be expressed in itself that short, and (as a natural consequence) can be built out of less primitive operators.&#8221;</p>


	<p>Except Forth. Or Factor. Or Joy. Let&#8217;s not be ignorant here :)</p>
</li><li id="comment-139"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_139'); }"  onmouseout="Element.hide('admin_comment_139');" >
  <div id="admin_comment_139" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/139', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-139',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/139" class="admintools">edit</a></div>
  <a name="comment-139"></a>
  
  <cite><strong><a href="http://kq9.net">Ralph</a></strong> </cite> said 1 day later:<br />
  <p>As a humble current user of <span class="caps">PHP</span> and MySQL &#8211; but having been around since <span class="caps">FORTRAN</span> and Assembler and happy <span class="caps">IBM 1620</span> Machine Language days &#8211; I want to say that I am enjoying the discussion here. In a way it sounds like a conversation among chess players, or artists.</p>


	<p>The &#8220;coolness&#8221; of a language, its elegance, its expressive power, are all important to language designers. I have constructed a few little languages, one of which even went into production in a small way. Recursive descent compiler, byte code interpreter, multi-threading at the application level. I understand the basics.</p>


	<p>But most of us, even those of us who do love elegance, nevertheless gravitate toward whatever language environment seems to get the job done with the least  total effort. That means common operations must be expressed as easy-to-read idioms.</p>


	<p>If you consider the spoken form of natural language for a moment, I think you will find that it is essentially all made out of idiom.</p>


	<p>In writing, I can express something like, &#8220;The ship did not contain any containers containing containers, but it did contain several containers containing parts used to construct containers&#8221;&#8212;and here I use a bit of abstraction, made possible by a few minor regularities in the English language.</p>


	<p>No one who has been reading this thread is likely to have had any trouble immediately understanding what I just wrote.</p>


	<p>But in spoken language, it is quite difficult to express the above both clearly and concisely. Even people frequenting this forum might not be able to express or understand that thought quickly in spoken language unless something of the context had been pre-established. The reason for that, I think, is that there is probably no established idiom for even such a very slightly complex thought. If such thoughts had to be expressed with any frequency, an idiom of some kind would immediately and &#8220;spontaneously&#8221; arise. Then the above sentence would become trivial to express and to understand.</p>


	<p>Syntactic sugar provides idioms for commonly performed actions. Obviously, then, it must also reduce generality. Idiom is supposed to reduce generality.</p>


	<p>&#8220;Admitting,&#8221; then, that one uses Perl, or even (gasp!) <span class="caps">PHP</span>, is like admitting that one uses ordinary spoken English. But we all do that.</p>


	<p>So, I&#8217;m eagerly awaiting Lisp on Rails, and all sorts of other great stuff, plus a hosting company that lets me write my web pages in that great stuff.</p>


	<p>Please. Use some of that &#8220;hard problem solving&#8221; ability to get it all accomplished, and I will be thrilled to be your very first customer. My current provider gets about $20 from me each month, depending on disk space and network bandwidth used.</p>


	<p>I am not trying to be facetious, much less rude. I am trying to raise a serious point, even though I did end on a rather familiar, even caustic note, for which I apologize if it jangled anyone&#8217;s nerves.</p>
</li><li id="comment-141"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_141'); }"  onmouseout="Element.hide('admin_comment_141');" >
  <div id="admin_comment_141" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/141', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-141',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/141" class="admintools">edit</a></div>
  <a name="comment-141"></a>
  
  <cite><strong><a href="http://null">Jules</a></strong> </cite> said 1 day later:<br />
  <p>This is a really good discussion! I&#8217;m a Ruby programmer, but I want to take a look at lisp. It looks good and I like its simplicity (based on only a few principles). I want to learn lisp because I enjoy programming. Am I right that there are 2 main lisps: Common Lisp and Scheme? Which one should I learn, what are the main differences?</p>
</li><li id="comment-142"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_142'); }"  onmouseout="Element.hide('admin_comment_142');" >
  <div id="admin_comment_142" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/142', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-142',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/142" class="admintools">edit</a></div>
  <a name="comment-142"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Jules, I would learn Common Lisp, but I&#8217;m biased :-).  I linked to Practical Common Lisp earlier on.  Take a look through the online chapters and see if you like it.  That&#8217;s a pretty good way to get started.</p>


	<p>There&#8217;s also Structure and Interpretation of Computer Programs, which is a free book from <span class="caps">MIT</span> and a classic in computer science.  You can pick up Scheme from it, but you&#8217;ll also get a deeper understanding of how Lisp-like languages work.</p>


	<p>There is a third Lisp in common use: Emacs Lisp.  There are allegedly more lines of Emacs Lisp in use than Scheme and Common Lisp combined.  Still, I don&#8217;t think I would recommend starting with Emacs Lisp, since it&#8217;s sort of quirky and sort of crippled.</p>


	<p>Anyway, happy lisping!</p>
</li><li id="comment-143" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_143'); }"  onmouseout="Element.hide('admin_comment_143');" >
  <div id="admin_comment_143" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/143', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-143',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/143" class="admintools">edit</a></div>
  <a name="comment-143"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Well, let me try to explain the differences between Common Lisp and Scheme, and other people can clarify&mdash;and fix my sweeping stereotypes. :-)</p>


	<p>Scheme is a very clean dialect of Lisp, with an emphasis on functional programming (see part one, above).  One of the most popular implementations is <a href="http://www.plt-scheme.org/" rel="nofollow"><span class="caps">PLT</span> Scheme</a>, which is often used with <a href="http://www.htdp.org/" rel="nofollow">How to Design Programs</a>.</p>


	<p>Common Lisp, on the other hand, tends to have better compilers and commercial support.  Common Lisp&#8217;s culture embraces a diverse range of programming styles: functional, object-oriented, and imperative styles are all common, as are macros (see part two, above).  Common Lisp also has more historical cruft than Scheme.  Looking upthread, people seem to like <a href="http://www.gigamonkeys.com/book/" rel="nofollow">Practical Common Lisp</a>.  You can download Common Lisp installers from the same site.</p>


	<p>Cultural and implementation differences aside, Common Lisp and Scheme are pretty much interchangable.  You can always find a macro package which adds <a title="Swindle" href="http://www.barzilay.org/Swindle/" rel="nofollow">Lisp features to Scheme</a>, or vice versa.  Either would be an excellent choice, and both are relevant to Ruby.</p>
</li><li id="comment-144"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_144'); }"  onmouseout="Element.hide('admin_comment_144');" >
  <div id="admin_comment_144" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/144', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-144',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/144" class="admintools">edit</a></div>
  <a name="comment-144"></a>
  
  <cite><strong>nemesis</strong> </cite> said 1 day later:<br />
  <p>Smalltalking with a Lisp:
&#8220;Ruby was inspired mainly by Smalltalk and Lisp&#8221;</p>


	<p>Don&#8217;t forget Perl!  Ruby is very perlish&#8230;</p>
</li><li id="comment-145"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_145'); }"  onmouseout="Element.hide('admin_comment_145');" >
  <div id="admin_comment_145" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/145', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-145',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/145" class="admintools">edit</a></div>
  <a name="comment-145"></a>
  
  <cite><strong><a href="http://www.democracynow.org/">Tayssir John Gabbour</a></strong> </cite> said 1 day later:<br />
  <p>Ralph, well, the tech.coop offers Lisp web hosting, and one of the guys there is working on something he humorously calls &#8220;Lisp on Lines.&#8221; (LoL.) Though I haven&#8217;t heard that it&#8217;s ready for common use yet.</p>


	<p>But keep in mind that I don&#8217;t &#8220;advocate&#8221; Lisp. At this moment, you will find barriers to entry. And while I think Common Lisp is a highly powerful tool, you need to take Lisp advocates&#8217; words with a grain of salt. They&#8217;re good at explaining the advantages of Lisp, but many do not take care to discuss its current downsides. (Like the ones this blog entry discusses.) Therefore they may mislead.</p>


	<p>Now, most advocates mislead, but I like to hold CL people to a higher standard. ;)</p>
</li><li id="comment-146"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_146'); }"  onmouseout="Element.hide('admin_comment_146');" >
  <div id="admin_comment_146" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/146', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-146',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/146" class="admintools">edit</a></div>
  <a name="comment-146"></a>
  
  <cite><strong>SB</strong> </cite> said 1 day later:<br />
  <p>nemesis:</p>


	<p>Ruby used to be Perlish, but nobody uses the blatant Perlisms ($_ etc.) anymore&#8230;</p>
</li><li id="comment-147"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_147'); }"  onmouseout="Element.hide('admin_comment_147');" >
  <div id="admin_comment_147" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/147', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-147',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/147" class="admintools">edit</a></div>
  <a name="comment-147"></a>
  
  <cite><strong>Jamie</strong> </cite> said 1 day later:<br />
  <blockquote>
	<blockquote>
	<blockquote>
	<p>&#8220;But my code is going to run much slower than Bill’s, because the iter macro lives in the compiler. The same goes for the IDv3 parser: It would look fine in Ruby, but get absolutely clobbered on performance.</p>

	</blockquote>



	</blockquote>



</blockquote>




<blockquote>
	<blockquote>
	<blockquote>
	<p>A year from now, this could actually be a pretty good sales pitch for Common Lisp. “It’s like Ruby, but it runs at full hardware speed!”</p>

	</blockquote>



	</blockquote>



</blockquote>




	<p>That is not really an argument for or against either language.  It is just saying that Ruby currently lacks a decent compiler.  That was true of Lisp, once, and it won&#8217;t be true of Ruby, one day.  One day Ruby will have a better compiler than Lisp if it stays popular enough to motivate a good commercial compiler to be written.</p>


	<p>Most of the arguments in favour of Lisp here seem to be around it&#8217;s macro facilities.  Yet, any reasonably regular language can have similar facilities &#8211; especially if there is defined a normal form which all syntactic sugar reduces.  And even better, if the sugar can be used in macro patterns as well as regular code.</p>


	<p>The point about Lisp being built out of 7 primitives isn&#8217;t really an accurate comparison.  Ruby is also only built from a few primitives, if you process the syntactic sugar &#8211; which is just the same as using a Lisp reader macro &#8211; and in both cases there are a plethora of extra features which you can treat as being built from macro extensions and additional I/O primitives.</p>


	<p>I&#8217;m looking at all the Lisp examples in this discussion, and I&#8217;m seeing the Ruby examples also presented here, and (if you ignore execution time, as that is just compiler maturity), they look roughly equivalent in capabilities, just presented with different sugar &#8211; and more sugar with fewer parens in Ruby&#8217;s case.</p>


	<p>&#8212;Jamie (who doesn&#8217;t use Lisp much and has never used Ruby, but does know what compilers can do)</p>
</li><li id="comment-148" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_148'); }"  onmouseout="Element.hide('admin_comment_148');" >
  <div id="admin_comment_148" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/148', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-148',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/148" class="admintools">edit</a></div>
  <a name="comment-148"></a>
  
  <cite><strong>Eric</strong> </cite> said 1 day later:<br />
  <p>Bill, I&#8217;m just Haskell newbie, but I&#8217;ll take a stab at your question.  You can find a lot of Haskell examples in <a href="http://www.haskell.org/tutorial/" rel="nofollow">A Gentle Introduction to Haskell</a>, and I&#8217;ve had good luck with the <a href="http://www.haskell.org/ghc/" rel="nofollow">Glasgow Haskell Compiler</a>.</p>


	<p>From a Lisp perspective, you&#8217;ll notice two things: (1) Haskell variables, once set, can never be changed, and (2) because Haskell uses lazy evaluation, you can easily represent infinite data structures.</p>


	<p>Lazy evaluation allows you to do all sorts of cool things.  You can represent iteration and data traversal in stunningly gorgeous ways.  (In effect, everthing&#8217;s a co-routine.) You can also, if you&#8217;re so inclined, define an infinite list of all primes.</p>


	<p>Now, these features are very cool, but they come at a high price: Since you can&#8217;t assign to Haskell variables, you have to write <em>everything</em> in a purely functional style.  Even I/O can be challenging, because it changes the outside world.  So how do you write real programs in Haskell?</p>


	<p>As it turns out, Haskell has a second powerful trick: monads.  Monads are pretty esoteric, but in Lisp terms, you might think of them as a way to metaprogram <em>control flow</em>.  The most common Haskell monad is <code>IO</code>, which makes Haskell statements execute sequentially, so you can talk to the outside world.  Other monads implement assignment, list comprehensions, continuations, and domain-specific languages (like the parser combinators above).</p>


	<p>Haskell can be a challenging language&mdash;some common programming idioms can only be expressed with monads, which are at least as hard as macros&mdash;but, like Prolog, Haskell makes certain programs look gorgeous.  And of course, there&#8217;s no reason why you couldn&#8217;t apply many Haskell ideas in Lisp, if that&#8217;s what you want.</p>


	<p>If you&#8217;ve mastered macros, and you&#8217;re looking for cool programming styles, Haskell&#8217;s not a bad place to start.</p>
</li><li id="comment-149"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_149'); }"  onmouseout="Element.hide('admin_comment_149');" >
  <div id="admin_comment_149" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/149', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-149',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/149" class="admintools">edit</a></div>
  <a name="comment-149"></a>
  
  <cite><strong>bill a</strong> </cite> said 1 day later:<br />
  <p>Jamie, these features of Lisp have nothing to do with the maturity of Lisp&#8217;s compiler.  Instead, they have everything to do with Lisp&#8217;s regular syntax.  It is indeed criminal that Ruby doesn&#8217;t even have a bytecode compiler, but this is not really the issue here.</p>


	<p>The code in Ruby is much more than &#8220;syntactic sugar.&#8221;  It is a complete formal language that has to be translated into an <span class="caps">AST</span> (abstract sy before being used.  The following Ruby code:</p>


	<pre><code>if foo.bar? and bar.baz?
   puts foo.to_s
end</code></pre>


	<p>does not simply expand into other code &#8211; it requires a full and complete Ruby parser to be transformed into anything useful.  If you still don&#8217;t believe me, consider the fact that there can be aribitrary expressions in the if&#8217;s test, and that Ruby (like Lisp) treats if&#8217;s as expressions, and allows them to be used anywhere.  I could write this:</p>


	<pre><code>if foo.bar? and bar.baz? and
    (89 + 44 + 54.0444).abs \== 4 and (if x == 4; 56; nil)
  do_this
end</code></pre>


	<p>There is no &#8220;syntactic sugar&#8221; that will simply and straightforwardly translate that into an <span class="caps">AST</span>.</p>


	<p>Lisp&#8217;s syntactic sugar, which I guess you aren&#8217;t personally familiar with, is completely different.  An example is the #&#8217;foo reader macro, which simply expands into (function &#8216;foo).  Or the &#8216;foo macro, which expands into (quote foo).  Lisp reader macros are merely shortcuts for other Lisp forms.  They are syntactic sugar in the strictest sense, and do little more than very straightforward code transformations.  As I hope my examples have made clear, this is pretty different from a language with syntax.</p>


	<p>I think the phrase &#8220;built out of 7 primitives&#8221; is misleading (although I think a poster higher up the thread was the first to use it).  A better term would be <em>described</em> in 7 primitives.  There is code over at paulgraham.com that implements a full Lisp evaluator using only those seven operators.  The whole thing is about a printed page long.  So the only point that can be made is that Lisp&#8217;s semantics can be completely explained with seven primitives.  Which is still a cool thing, but not the same as what was being claimed.  To build a language you still need a function to take strings and turn them into lists, and other handy things like I/O support and so on.  (incidentally, here is Paul Graham&#8217;s code: http://lib.store.yahoo.net/lib/paulgraham/jmc.lisp).</p>


	<p>If you can point me to Ruby code equivalent to Paul Graham&#8217;s, I will concede the argument.  But you won&#8217;t, and you can&#8217;t, because that isn&#8217;t how Ruby works.  Ruby has a syntax, and Ruby needs a full parser to get from that syntax to an <span class="caps">AST</span>.  Because Lisp code is naturally an <span class="caps">AST</span>, things are very different.</p>


	<p>Also, it&#8217;s true that if Ruby could be transformed into a more regular language you could write macros with it.  This is, in fact, probably possible with Ryan Davis&#8217;s ParseTree package.  But now your macros have to output (and work from) an intermediate format, instead of straight Ruby code.  That intermediate format will be some kind of <span class="caps">AST</span> and the mapping between real Ruby and that intermediate form will almost certainly be a hassle to manage, so why not ditch the syntax and use Lisp&#8217;s model, where all code is naturally and automatically an <span class="caps">AST</span>, and macros simply follow from that?</p>
</li><li id="comment-150"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_150'); }"  onmouseout="Element.hide('admin_comment_150');" >
  <div id="admin_comment_150" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/150', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-150',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/150" class="admintools">edit</a></div>
  <a name="comment-150"></a>
  
  <cite><strong>Haskell Junkie</strong> </cite> said 2 days later:<br />
  <p>bill, <p>
<a href="http://hoc.sourceforge.net/examples.html" rel="nofollow">Here&#8217;s</a> an example of a simple arithmetic parser and evaluator using the <a href="http://www.cs.uu.nl/~daan/parsec.html" rel="nofollow">Parsec</a> library.  And below is a little snippet of a non-deterministic program in action.  Say you want find a pair of numbers which multiply out to 8633.  Well, this isn&#8217;t the most efficient way to do it, but it looks nice and declarative&#8230;</p>


<pre>
-- try combinations of factors between 2 and 100 and cull the wrong ones
import Control.Monad
main = print ( do a &lt;- [2..100]
                  b &lt;- [2..100]
                  if a*b == 8633 then return (a,b) else mzero )
</pre>

	<p>...nothing new there, something that could also be done in lisp without macros (especially if your lisp comes with an &#8220;amb&#8221; operator).  But it is nice to note that the <a href="http://www.nomaware.com/monads/html/listmonad.html" rel="nofollow">list monad</a> which makes this work is implemented in 7 lines of code.</p>
</li><li id="comment-151"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_151'); }"  onmouseout="Element.hide('admin_comment_151');" >
  <div id="admin_comment_151" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/151', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-151',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/151" class="admintools">edit</a></div>
  <a name="comment-151"></a>
  
  <cite><strong>bdw</strong> </cite> said 2 days later:<br />
  <p>Well, I&#8217;ve considered the same thing, really. Ruby isn&#8217;t a &#8216;lisp&#8217; because it is a denser functional language. Ruby isn&#8217;t really a functional language; <span class="caps">LISP</span> is.</p>


	<p>Ruby would have been a &#8216;new <span class="caps">LISP</span>&#8217; (in the same way that &#8216;yellow is the new black&#8217;) <strong>if</strong> it would have been just a little more consistent. Instead of 
loop { obj.meth } 
it should have done
loop.obj.meth
which would complete it being Consistently Object Oriented&#8482;.</p>


	<p>You see, the great thing behind Lisp isn&#8217;t the macros, although they are nice.</p>


	<p>Instead, there are two real things that Lisp provides, which aren&#8217;t found in other language. To sum:</p>


	<p>1): In Lisp, everything is a function. &#8216;If&#8217; is a function, &#8216;cond&#8217; is a function , &#8216;defun&#8217; is a function. &#8216;and&#8217; and &#8216;or&#8217; are not logical operators, they are functions, too. They return values, as well. With that in mind, it becomes possible to write very powerfull, dense code.</p>


	<p>2): Lisp has only one syntax rule (with the exeption of read macros):
(function arguments). Any argument may be a function. This is simple and consistent, and one can rely on it being this way. That&#8217;s not to say it isn&#8217;t mind-bending and it definitely can drive one mad. But it is the <strong>only</strong> syntax. If ruby had been just a little bit more consistent, it would truly have been &#8216;the new <span class="caps">LISP</span>&#8217;; instead, it is the latest new OO language.</p>


	<p>Mind you, Ruby is a very nice language and it has very nice (though imperfect) syntax, community and libraries, and for  quick webapps, it definitely rocks.</p>


	<p>But it isn&#8217;t a new <span class="caps">LISP</span>, not by a long shot.</p>
</li><li id="comment-152" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_152'); }"  onmouseout="Element.hide('admin_comment_152');" >
  <div id="admin_comment_152" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/152', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-152',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/152" class="admintools">edit</a></div>
  <a name="comment-152"></a>
  
  <cite><strong>Eric</strong> </cite> said 2 days later:<br />
  <p><span class="caps">BDW</span>, the operators you list (<code>if</code>, <code>defun</code>, etc.) are technically &#8220;special forms,&#8221; not functions, because they don&#8217;t necessarily evaluate all their arguments.  Other than that, your point is good.</p>


	<p>Bill, here&#8217;s some Ruby code (based on ParseTree and an unpublished library of my own), which isn&#8217;t <em>entirely</em> unreasonable:</p>


<div class="typocode"><pre><code class="typocode_ruby "><span class="ident">assert_body</span><span class="punct">(</span><span class="ident">call</span><span class="punct">(</span><span class="ident">lit</span><span class="punct">(</span><span class="number">2</span><span class="punct">),</span> <span class="punct">:+,</span> <span class="ident">lit</span><span class="punct">(</span><span class="number">3</span><span class="punct">)))</span> <span class="keyword">do</span>
  <span class="number">2</span> <span class="punct">+</span> <span class="number">3</span>
<span class="keyword">end</span></code></pre></div>

	<p>The expression in parentheses builds a parse tree, which <code>assert_body</code> compares to the block&#8217;s <span class="caps">AST</span>.  This is a small step towards recreating Paul&#8217;s example.</p>


	<p>Jamie, speaking as a minor contributor to several Lisp compilers, I doubt that Ruby will ever be as fast as Common Lisp.  There&#8217;s two big obstacles:</p>


	<p>(1) Ruby metaprogramming happens at runtime, but Lisp macros run in the compiler.  It&#8217;s hard to beat zero runtime cost. :-)</p>


	<p>(2) Ruby supports a variety of dynamic features, such as duck typing and <code>method_missing</code>, which are <em>much</em> harder to optimize than the equivalent features in Lisp.</p>


	<p>Of course, the best SmallTalk VMs are <a href="http://www.smallscript.net/" title="SmallScript" rel="nofollow">very good</a>, and a hypothetical Ruby VM could certainly be adequate for almost all applications.</p>
</li><li id="comment-153"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_153'); }"  onmouseout="Element.hide('admin_comment_153');" >
  <div id="admin_comment_153" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/153', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-153',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/153" class="admintools">edit</a></div>
  <a name="comment-153"></a>
  
  <cite><strong>bill a</strong> </cite> said 2 days later:<br />
  <p><span class="caps">BDW</span>, uh, a lot of the stuff in your comment is confusing and/or wrong.  Look into that.</p>
</li><li id="comment-154"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_154'); }"  onmouseout="Element.hide('admin_comment_154');" >
  <div id="admin_comment_154" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/154', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-154',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/154" class="admintools">edit</a></div>
  <a name="comment-154"></a>
  
  <cite><strong>bill a</strong> </cite> said 2 days later:<br />
  <p>Eric, that&#8217;s cool.  I figured ParseTree would eventually be able to do something like that.  Still, I think that even writing macros in an intermediate format is a lot less convenient and maintainable than Lisp macros &#8211; what happens when the interface to ParseTree changes?  What happens when a new version of Ruby comes out and breaks everything?  I&#8217;m still sticking with Lisp.  :)</p>
</li><li id="comment-155"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_155'); }"  onmouseout="Element.hide('admin_comment_155');" >
  <div id="admin_comment_155" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/155', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-155',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/155" class="admintools">edit</a></div>
  <a name="comment-155"></a>
  
  <cite><strong>PleaseDontKillMe</strong> </cite> said 2 days later:<br />
  <p><span class="caps">NOTE</span>: I originally posted this on Zifus  blog up there. Posting here for completion&#8217;s sake. You may accuse me of trolling, or you may read this document as something which has a degree of truth to it.</p>


	<p>[Snipped, on grounds of excessive profanity.  Please keep it polite.  -Ed</p>


	<p>You can find the original comment on the <a href="http://www.blogger.com/comment.g?blogID=19550706&#38;postID=113368193930148824" rel="nofollow">Zifus blog</a>, starting with &#8220;I think most &#8216;dead&#8217; or &#8216;dying&#8217; languages&#8230;&#8221;]</p>
</li><li id="comment-156"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_156'); }"  onmouseout="Element.hide('admin_comment_156');" >
  <div id="admin_comment_156" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/156', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-156',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/156" class="admintools">edit</a></div>
  <a name="comment-156"></a>
  
  <cite><strong>bill a</strong> </cite> said 2 days later:<br />
  <p>OK then.  Winter break starts in two weeks.  I will write, document, and release Lisp on a Ladder.</p>


	<p>I promise.</p>


	<p>Will that satisfy the naysayers?</p>
</li><li id="comment-157" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_157'); }"  onmouseout="Element.hide('admin_comment_157');" >
  <div id="admin_comment_157" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/157', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-157',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/157" class="admintools">edit</a></div>
  <a name="comment-157"></a>
  
  <cite><strong>Eric</strong> </cite> said 2 days later:<br />
  <p>Bill, if the interface to ParseTree changes, I&#8217;ll just hack around inside my library until the test cases run again.  The code above is actually written against my own high-level <span class="caps">API</span>, not against ParseTree itself.</p>


	<p>The real danger is a VM change in Ruby 2.0, which would pretty much kill ParseTree.  I suppose if somebody builds something stunningly cool right now, it might help keep ParseTree alive on a future VM.  Not a good argument for a production system. :-/</p>
</li><li id="comment-158"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_158'); }"  onmouseout="Element.hide('admin_comment_158');" >
  <div id="admin_comment_158" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/158', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-158',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/158" class="admintools">edit</a></div>
  <a name="comment-158"></a>
  
  <cite><strong>Johnny</strong> </cite> said 2 days later:<br />
  <p>(I know, I know&#8230;)</p>


	<p>I agree, my &#8220;PleaseDontKillMe&#8221; friend. Programming is a means, not an end in itself. Refurbishing your algorithms aren&#8217;t the purpose of programming. You need all the help that you can get, free or commercial, because programming is hard! Inviting people to the &#8220;hard side of the force&#8221; won&#8217;t work, ever.</p>
</li><li id="comment-159"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_159'); }"  onmouseout="Element.hide('admin_comment_159');" >
  <div id="admin_comment_159" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/159', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-159',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/159" class="admintools">edit</a></div>
  <a name="comment-159"></a>
  
  <cite><strong>Mike</strong> </cite> said 3 days later:<br />
  <p>You mention python in your article, but then you move to ruby.  Ruby is a great language.</p>


	<p>I started in <span class="caps">LISP</span> in the late 80&#8217;s then went to python in the early 90&#8217;s.</p>


	<p>Python has always had native rich functional support.</p>


	<p>- lambda
- map
- apply</p>


	<p>Python 2.2 (release python now 2.4)
added
  &#8211; iterators</p>


	<p>Python 2.4 added decorators that simplify generic programming.</p>


	<p>Here are some intersting python as <span class="caps">LISP</span></p>


	<p>Nice article on <span class="caps">LISP</span> and Python comparison</p>


	<p>http://www.norvig.com/python-lisp.html</p>


	<p>Functional Programming in Python
http://www-128.ibm.com/developerworks/linux/library/l-prog.html</p>


	<p>http://www-128.ibm.com/developerworks/linux/library/l-prog2.html</p>


	<p>MultiMethods:
http://www-128.ibm.com/developerworks/linux/library/l-pydisp.html</p>


	<p>Generic Programming:
http://www-128.ibm.com/developerworks/library/l-cppeak2/</p>
</li><li id="comment-160"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_160'); }"  onmouseout="Element.hide('admin_comment_160');" >
  <div id="admin_comment_160" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/160', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-160',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/160" class="admintools">edit</a></div>
  <a name="comment-160"></a>
  
  <cite><strong>Eric</strong> </cite> said 3 days later:<br />
  <p>Thank you for the decorators link; that&#8217;s an especially nice approach.  Ruby handles this a bit less gracefully.</p>


	<p>For more on <code>lambda</code> and <code>map</code> in Python, and why they&#8217;re not quite as helpful as they might be, see the <a href="http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp#comment-109" rel="nofollow">earlier discussion</a>.</p>
</li><li id="comment-161"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_161'); }"  onmouseout="Element.hide('admin_comment_161');" >
  <div id="admin_comment_161" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/161', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-161',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/161" class="admintools">edit</a></div>
  <a name="comment-161"></a>
  
  <cite><strong>Brad</strong> </cite> said 3 days later:<br />
  <p>Having read about 1/2 through the book, what strikes me is that Ruby seems to be roughly the same language as smalltalk (caveat, i don&#8217;t know the meta-programming layer fo Ruby) with a lot of extra syntax.</p>


	<p>As I read the Ruby code i see how with slight tweaks to turn it into smalltalk&#8230;which also looks a lot more elegant to me.</p>


	<p><a Common Lisp and Smalltalk fan rel="nofollow"></p>
</li><li id="comment-162"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_162'); }"  onmouseout="Element.hide('admin_comment_162');" >
  <div id="admin_comment_162" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/162', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-162',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/162" class="admintools">edit</a></div>
  <a name="comment-162"></a>
  
  <cite><strong>PleaseDontKillMe</strong> </cite> said 3 days later:<br />
  <p>Eric, I&#8217;m dissappointed. You could have just deleted the offensive words because the intent of the post was not to troll.</p>


	<p>But this is your blog and that is fine.</p>


	<p>Even though, there were some uncomfortable things that I said and I hope it wasn&#8217;t because of those uncomfortable truths (and I don&#8217;t meand the &#8220;F&#8221; words) that you decided to pull the comment whole hog.</p>


	<p>this also illustrates one of the points I tried to make. An un-necessarily haughty attitude when it comes to ideas which challenge the status-quo in our mind.</p>


	<p>My apologies for &#8220;excessive profanity&#8221;.</p>


	<p>What I find even more &#8220;profanerer&#8221; is all the talk about the beauty of our computational navels, while supposedly &#8220;inferior&#8221; languages whiz by us in the race for survival (essentially mindshare)</p>


	<p>You may be the sleekest species for a hundred million years, but if you can&#8217;t compete with the humble shrew, then <span class="caps">YOU</span> are the eventual loser. I don&#8217;t care how many shiny scales and sharp fangs you got!</p>


	<p>Languages mold their speakers, and the speakers mold their languages. Latin and Sanskrit maybe the &#8216;best&#8217; languages, but I wonder why the world don&#8217;t use them no-mo ??</p>


	<p>My question to the Lispers/Forthers/Smalltakers was:</p>


	<p>Do you want to be the Sanskrit of the world, spoken only by the high-priests and teetring always on the brink of extinction owing your existence to the continued existence of the high-priests?</p>


	<p>or do you want to be the lingua franca, (lets say, English) of the world? Spoken by the masses to make their lives happen on a day to day basis?</p>


	<p>The choice is yours, and if you &#8220;love&#8221; the language, then you will do things which are not short-sighted in nature (closed source/obfuscation/needless punditry) and which help the cause of your so called &#8216;love&#8217; (open sourcing, helping, creation of killer apps for mass penetration)</p>


	<p>By killer apps I don&#8217;t mean other dialects of the favorite language (or extremely expensive retail software)</p>


	<p>In cany case, thanks for starting a thought provoking post.</p>


	<pre><code>::AAEBACMD::</code></pre>
</li><li id="comment-163"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_163'); }"  onmouseout="Element.hide('admin_comment_163');" >
  <div id="admin_comment_163" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/163', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-163',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/163" class="admintools">edit</a></div>
  <a name="comment-163"></a>
  
  <cite><strong>Jim</strong> </cite> said 3 days later:<br />
  <p>bill a,</p>


	<p>Please make Lisp on a Ladder.</p>


	<p>Can you make it cross-platform? Will it run on more than one compiler? There&#8217;s a lot of fragmentation causing duplication of effort. What do we need to make a beautiful language like Lisp gain mindshare?</p>


	<p>The Lisp community needs more development and collaboration.  It needs some more exciting things going on!</p>
</li><li id="comment-164"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_164'); }"  onmouseout="Element.hide('admin_comment_164');" >
  <div id="admin_comment_164" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/164', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-164',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/164" class="admintools">edit</a></div>
  <a name="comment-164"></a>
  
  <cite><strong>bill a</strong> </cite> said 4 days later:<br />
  <p>Jim:  Yes, it would have to be as cross-platform and cross-implementation as humanly possible.  I will be sure to test it on <span class="caps">CLISP</span>, since anything that runs on <span class="caps">CLISP</span> will run on Linux, FreeBSD, <span class="caps">OS X</span>, Windows, etc.</p>


	<p>I&#8217;m also planning to release tutorial videos as part of the project (as soon as xvidcap stops crashing when I hit record) on a whole variety of topics, from the basics of Lisp, to using Emacs + <span class="caps">SLIME</span>, to the specifics of the Lisp on a Ladder framework, to developing a toy application (let&#8217;s say a blog) in some ridiculous amount of time &#8211; let&#8217;s say four minutes.</p>


	<p>While working on this, I&#8217;ve realized the answer to a challenge lots of people make: why is there no equivalent to Ruby on Rails in Lisp?  I think the answer is that most frameworks exist to save their user the repetition and messiness of typing out similar constructs over and over.  With macros, that need is less acute.  With environments like <span class="caps">SLIME</span> giving you information about what parameters a macro or function takes, this is also less important.</p>


	<p>In any case, here are some of the features I&#8217;m considering in LoaL:</p>


	<p>- at the user&#8217;s option, LoaL will automatically manage your database schema (this can be turned on or off on either a database-wide or a table-wide basis).  So if I make a change to my model code, LoaL would check to make sure the schema matches what&#8217;s actually in the table.  If it doesn&#8217;t, and the user isn&#8217;t in production mode, it will offer to bring the schema into line with the model, being careful to warn about dropping columns with data in them and so on.</p>


	<p>- compiled view templates, so minimal time is spent building a view to be sent to the user</p>


	<p>- instead of shoehorning things into the object-oriented model, LoaL will be able to define language constructs for specific tasks.  In RoR, for instance, a method of the controller is automatically available to the public unless I make it private; LoaL will use a (defaction &#8230;) form that will make this a non-issue &#8211; things are only actions if you make them actions, because actions and methods are different concepts.</p>


	<p>- less stub generation than Rails.  There will probably be some kind of stub generation available, but ideally it would only be to create the application directory and one or two files.  With interactive development, figuring out what goes in a test file isn&#8217;t as difficult because the documentation for every macro and function is available at development-time; with macros, stubs aren&#8217;t needed as much because the user will be able to say things like (deftestsuite (deftestcase &#8230;...) ....) instead of relying on the framework to properly generate a test file.</p>


	<p>- in development mode (at least), LoaL will ideally give you more certainty about your code &#8211; making sure you don&#8217;t render nonexistent views or redirect to nonexistent actions; making sure you don&#8217;t refer to nonexistent columns in the table.  There will be zero cost to this, because it will all be done at compile-time/load-time.  (I haven&#8217;t completely decided whether this is worthwhile or not).</p>


	<p>- probably some more</p>


	<p>LoaL is inspired by Rails but it is neither a clone nor totally an attempt to redesign it.  It will be more for public-relations reasons than anything else, since there are certainly frameworks coming that will do things better than LoaL will.</p>


	<p>Here is a darcs repository with an early, early, <span class="caps">EARLY</span> draft (DRAFT!) of some of the constructs LoaL <span class="caps">MIGHT</span> offer: <a href="http://www.galoot.org/~bill/code/loal/" rel="nofollow">loal repo</a> .  The file driver.lisp can be viewed in a browser and gives you an idea of what <span class="caps">MIGHT</span> (have I stressed the tentative nature of this enough yet?  No?  OK, well, driver.lisp is the result of only about an hour of thinking, so I&#8217;m sure you can see that it will almost certainly change in drastic ways).  There are the beginnings of a portal at <a href="http://www.galoot.org/~bill/code/loal-web" rel="nofollow">loal-web</a></p>


	<p>Friendlier <span class="caps">URL</span>&#8217;s coming soon!  Also, any tips on doing narrated video captures in X (on Linux) would be appreciated, since I can&#8217;t get xvidcap to stop hating me.</p>
</li><li id="comment-165"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_165'); }"  onmouseout="Element.hide('admin_comment_165');" >
  <div id="admin_comment_165" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/165', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-165',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/165" class="admintools">edit</a></div>
  <a name="comment-165"></a>
  
  <cite><strong>JAP</strong> </cite> said 4 days later:<br />
  <p>(for the sake of completeness):</p>


	<p><strong>SB</strong>: thank you for correcting my ignorance, but here I would like to bring a statement of Albert Einstein: &#8220;make everything as simple as possible, <strong>but</strong> <strong>not</strong> <strong>simpler</strong>!</p>


	<p>That says it all: when you go too far, then you loose something (maybe important), and here it would be: <strong>flexibility</strong>.</p>


	<p>So, you really <strong>can</strong> create some language that seems simpler than Lisp, but then at the same time you loose really too much!</p>


	<p>(Isn&#8217;t that really interesting? You can create a language out of, say, 25 primitive operators, and have something very handy, and you can create a language out of, say, 3 primitive operators, and you have something as-concise-as-no-one-could-ever-beat, but hey, you have lost all of the flexibility, and never will be able to convince the really smart people of this planet!)</p>


	<p>I would summarize it this way: the really &#8220;perfect formula&#8221; for making a programming language is to bring it to exactly that 7 primitive operators that are forming Lisp.
Then you have &#8220;touched heaven&#8221;! (Please don&#8217;t take this too literally, I know that in practice this has to be extended, but not in <strong>spirit</strong>. Anyway, that doesn&#8217;t really touch the theory).</p>


	<p>Any comments, anybody?</p>


	<p>-JAP</p>
</li><li id="comment-168"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_168'); }"  onmouseout="Element.hide('admin_comment_168');" >
  <div id="admin_comment_168" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/168', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-168',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/168" class="admintools">edit</a></div>
  <a name="comment-168"></a>
  
  <cite><strong>Jules</strong> </cite> said 50 days later:<br />
  <p>There is a language called IO:</p>


	<p>http://www.guldheden.com/~sandin/amalthea.html</p>


	<p>It is a very simple language, the only thing is continuations. You can build pairs with continuations, and thus lists, integers, strings, trees.</p>


	<p>But it is really hard to understand. This:</p>


	<p>write 5;
write 6;
terminate</p>


	<p>Does a lot of things. It first calls &#8220;write&#8221; with <span class="caps">TWO</span> arguments: 5 and &#8220;write 6; terminate&#8221;. This prints it&#8217;s first argument, and then executes the second argument (the rest of the program). write 6 does the same: print 6 to the screen, and call &#8220;terminate&#8221;. Terminate doesn&#8217;t call the rest of the program, so the program will terminate.</p>


	<p>Integers are continuations too:</p>


	<p>1; -&gt; a;
write a;
terminate</p>


	<p>1 is a &#8220;function&#8221; It calls the rest of the program with itself as an argument.  The -&gt; thing assigns the argument to a, and calls the rest of the program.</p>


	<p>So you can express everything as continuations. It&#8217;s just nice to have these built-in integers and strings to make your programs cleaner, but they are not needed.</p>


	<p>So this language has only one concept: continuations. You can build for-loops with it, goto&#8217;s, etc. IO is <span class="caps">VERY</span> flexible.</p>


	<p>But does this make the language &#8220;better&#8221;? I find it very hard to understand, but function calls and for loops are hard to understand too (if you are not a programmer). With some practice, first-class continuations are very powerful tools, it&#8217;s the only thing  you need.</p>


	<p>I think that every Lisp programmer should check this out. Hard to understand, but very powerfull, and you don&#8217;t need macros, because you can express everything concise with continuations.</p>
</li><li id="comment-169"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_169'); }"  onmouseout="Element.hide('admin_comment_169');" >
  <div id="admin_comment_169" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/169', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-169',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/169" class="admintools">edit</a></div>
  <a name="comment-169"></a>
  
  <cite><strong><a href="http://null">Rhodry</a></strong> </cite> said 62 days later:<br />
  <p>Hey people,</p>


	<p>Interesting discussion. As a Ruby / Rails afficionado its been quite interesting to watch. But as a newbie &#8220;Pragmatic Programmer&#8221; I am trying to learn a new language each year. After the discussions above, 2006 may just be the &#8220;Common Lisp&#8221; year :)</p>


	<p>As a vaguely offtopic curiosity for the veteran Lisp hackers in the list &#8230;</p>


	<p>Has anyone looked at &#8220;Intentional Programming&#8221;? It was originally (10 years ago) a Microsoft Research project for interactive graphical generation / transformation and reduction of Abstract Syntax Trees [AST] &#8211; recently it has been taken into other commercial hands who are trying (but are always delaying) to realize a commercial solution http://www.intentsoft.com/.  The original hype sounded brilliant &#8211; a graphically rich domain specific language integrated development environment [IDE] &#8211; but nothing has yet come of it. (Unlike Rails <sly grin>)</p>


	<p>Now, given the vaunted regularity of syntax and metaprogramming capabilities of Lisp (not to mention the existent <span class="caps">IDE</span> features of Emacs), surely such a wide-scale, platform-neutral, domain specific graphical visualiser and metaprogrammer environment would fit better within a Lisp variant than Microsoft C/C++ [the original technology bootstrap].</p>


	<p>Anyone got any ideas as to why 
a) No Lisp hacker group hasn&#8217;t cottoned on to the ideas in the published research and given the construction of an Intentional Programming environment a go?
b) Anyone would ever think that C/C++ would be an easier way to reason about the computation/compilation process than Lisp?</p>


	<p>Wouldn&#8217;t it be good to be able to simply activate an edition enzyme in your <span class="caps">IDE</span> so that your new source package was instantly re-represented as Ruby or Python or even schematic diagrams? Whatever language is closer to your thoughts&#8230; and better fits the solution :)  {Might even reduce some of the language holy wars :)}</p>


	<p>Hoping to stimulate some thoughts&#8230;</p>


	<p>Rhodry</p>
</li><li id="comment-172"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_172'); }"  onmouseout="Element.hide('admin_comment_172');" >
  <div id="admin_comment_172" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/172', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-172',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/172" class="admintools">edit</a></div>
  <a name="comment-172"></a>
  
  <cite><strong><a href="http://www.democracynow.org/">Tayssir John Gabbour</a></strong> </cite> said 76 days later:<br />
  <p>Not only is the Lisp world aware of Intentional Programming, Interlisp was likely the forerunner&#8212;and a well-known Lisper [1] was the cofounder of Simonyi&#8217;s intentional programming company.
http://wiki.alu.org/AudioVideo</p>


	<pre><code>Kiczales, a coauthor of Lisp's metaobject protocol. Last I heard, he departed Intentsoft.</code></pre>
</li><li id="comment-175"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_175'); }"  onmouseout="Element.hide('admin_comment_175');" >
  <div id="admin_comment_175" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/175', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-175',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/175" class="admintools">edit</a></div>
  <a name="comment-175"></a>
  
  <cite><strong>Rhodry</strong> </cite> said 88 days later:<br />
  <p>I humbly withdraw my misguided implication that the Lisp programming community were not involved in intentional software development and apologise for any offence&#8230;.</p>


	<p>Rhodry</p>
</li><li id="comment-179"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_179'); }"  onmouseout="Element.hide('admin_comment_179');" >
  <div id="admin_comment_179" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/179', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-179',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/179" class="admintools">edit</a></div>
  <a name="comment-179"></a>
  
  <cite><strong><a href="http://feyeleanor.livejournal.com">Eleanor McHugh</a></strong> </cite> said 130 days later:<br />
  <p>As an academically savvy Ruby programmer who works on real-world application development I very much enjoyed reading your article, but I find the religious divide that&#8217;s apparent in various of the reactions to it rather strange.</p>


	<p>I came to Ruby via a circuitous route and my sole concern in using it is whether or not I can concentrate on the abstractions necessary to deliver a maintainable application efficiently and in a timely fashion: this is an area in which Ruby shines. It may have syntax, but it shares this feature with human language and most communications protocols &#8211; unsurprisingly really as at the end of the day both source code and real-world computational side-effects are intended for a human audience.</p>


	<p>Lisp has in part failed to gain mindshare with the broader development community because ultimately it is a mathematical abstraction and (whilst rare amongst classic hackers) most people are perturbed by mathematics. It is an interesting notation if one wishes to develop software as a symbolic representation of a computational parse tree but that is only one theoretical model of the programming process.</p>


	<p>Ruby on the other hand is an example of a class of languages that will become more prevalent in future years, where the abstractions that make Lisp so powerful are presented in a form that is palatable to those of us with an artistic/lingustic bias as opposed to a mathematical one.</p>


	<p>This is not a new development. It seems to me that Ruby shares much in common with Icon and Pop-II (just as <span class="caps">PERL</span> does with <span class="caps">SNOBOL</span>), both languages that have found adherents outside the computer science fraternity despite their strong theoretical foundations. Where Ruby differs is that it has a killer application &#8211; the Internet. Anyone who has looked at the Rails web application framework can instantly see the potential compared to the slew of ad hoc scripting languages against which it is currently competing, and most of that power comes from the relative ease with which Ruby handles meta-programming.</p>


	<p>Ruby makes object orientation, functional meta-programming painless for the non-technical user and introduces elegance and beauty into tasks which whilst achieveable in many apparently equivalent languages would require inelegant hacks. In my opinion this is a very good thing because elegant software is in general easier to maintain &#8211; something which I&#8217;m sure the hardcore of Lisp hackers would recognise.</p>


	<p>For me it&#8217;s not really a case of Lisp or Ruby being the more powerful language in an absolute sense, but of which is the more powerful tool in the hands of a particular developer looking to use the highest levels of abstraction possible with the minimum level of theoretical knowledge. As an amathematical person I consider Ruby more powerful for me as an individual, even though that may not be the case for many previous commentators.</p>


	<p>Given the ease with which a non-technical user can gain a good grasp of Ruby I suspect that it has the potential to be to network programming what <span class="caps">BASIC</span> was to the microcomputer revolution of the 1970&#8217;s and 1980&#8217;s. The speed with which Ruby on Rails is taking off in the web development arena is just the tip of this particular iceberg.</p>


	<p>So to summarise: Ruby is a powerful language with a syntax that is easy even for non-programmers to get to grips with. It includes concepts to do with block closures, object-orientation and meta-programming which are usually absent from languages accessible to novice programmers and provides idioms for their usage which are easy to remember and use. There are without doubt architectural techniques which can be utilised more easily in Lisp, but as to whether or not those are techniques which are actively useful for general software development is something that I think is open to debate.</p>


	<p>Eleanor</p>
</li><li id="comment-183"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_183'); }"  onmouseout="Element.hide('admin_comment_183');" >
  <div id="admin_comment_183" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/183', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-183',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/183" class="admintools">edit</a></div>
  <a name="comment-183"></a>
  
  <cite><strong>Daniel</strong> </cite> said 141 days later:<br />
  <p>Eleanor, excellent comment. In response, I offer a Dijkstra quote:</p>


<blockquote><i>Don&#8217;t blame me for the fact that competent programming, as I view it as an intellectual possibility, will be too difficult for &#8216;the average programmer&#8217;, you must not fall into the trap of rejecting a surgical technique because it is beyond the capabilities of the barber in his shop around the corner.</i></blockquote>
</li><li id="comment-185"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_185'); }"  onmouseout="Element.hide('admin_comment_185');" >
  <div id="admin_comment_185" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/185', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-185',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/185" class="admintools">edit</a></div>
  <a name="comment-185"></a>
  
  <cite><strong>cmy</strong> </cite> said 149 days later:<br />
  <blockquote>
	<p>Eleanor, excellent comment. In response, I offer a Dijkstra quote&#8230;</p>

</blockquote>




	<p>While I certainly hold Dijkstra in the highest respect, you have to rememebr that this is the same guy that counts <span class="caps">GOTO</span> statements and hand-writes his paper submissions.</p>


	<p>While it&#8217;d be nice to adhere to ideals, some of us have to live in reality.</p>
</li><li id="comment-186"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_186'); }"  onmouseout="Element.hide('admin_comment_186');" >
  <div id="admin_comment_186" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/186', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-186',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/186" class="admintools">edit</a></div>
  <a name="comment-186"></a>
  
  <cite><strong>Alexander Medvedev</strong> </cite> said 164 days later:<br />
  <p>Yeah, Ruby example is more straightforward, compared to the Lisp&#8217;s one that you give:</p>


	<p>(remove-if (lambda (n) (= (mod n 3) 1))
<br>&nbsp;&nbsp;(mapcar (lambda (n) (* n n))
<br>&nbsp;&nbsp;&nbsp;&nbsp;&#8217;(1 2 3)))</p>


	<p><span class="caps">BUT</span>. More can be said in Lisp&#8217;s defence than you say. Macros can be used not just to make lambdas more consize. If you consider the above expression hard to read, and prefer to read in the order of computation, as in your Ruby example, take a look at this:</p>


	<p>(stream-2nd-arg &#8216;(1 2 3)
<br>&nbsp;&nbsp;(mapcar (lambda (n) (* n n)))
<br>&nbsp;&nbsp;(remove-if (lambda (n) (= (mod n 3) 1))))</p>


	<p>Note that mapcar and remove-if have no 2nd argument. Where do they get it from? From the previous computation. The first arg to &#8216;stream-2nd-arg&#8217; macro is evaluated first. Other args are function calls evaluated after that in turn, and each gets their 2nd argument from the previous call.</p>


	<p>Simple, concise and readable too.</p>


	<p>The implementation of stream-2nd-arg macro is left as an excersize to the reader :)</p>
</li><li id="comment-187"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_187'); }"  onmouseout="Element.hide('admin_comment_187');" >
  <div id="admin_comment_187" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/187', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-187',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/187" class="admintools">edit</a></div>
  <a name="comment-187"></a>
  
  <cite><strong>John Collins</strong> </cite> said 165 days later:<br />
  <p>I am so glad I found a guru versed in all 3 of:  Ruby, <span class="caps">LISP</span>, and functional programming.</p>


	<p>In <span class="caps">LISP</span> and Python, I can use the apply function to pass a parameter list to a function declared to accept those parameters and bind them directly to each of the formal parameters in the declaration of the called function.</p>


	<p>In Ruby, sure, I can pass a list of parameters as a single list to a *parameter.  But that is not what I want to do.</p>


	<p>Any idea of how to carry this off in Ruby, or is a close analog to the apply function just missing from Ruby?</p>
</li><li id="comment-188"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_188'); }"  onmouseout="Element.hide('admin_comment_188');" >
  <div id="admin_comment_188" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/188', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-188',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/188" class="admintools">edit</a></div>
  <a name="comment-188"></a>
  
  <cite><strong>Eric</strong> </cite> said 169 days later:<br />
  <p>Try this:</p>


<div class="typocode"><pre><code class="typocode_ruby "><span class="ident">obj</span><span class="punct">.</span><span class="ident">meth</span> <span class="ident">arg1</span><span class="punct">,</span> <span class="ident">arg2</span><span class="punct">,</span> <span class="punct">*</span><span class="ident">more_args</span></code></pre></div>

	<p>It&#8217;s roughly equivalent to Scheme&#8217;s &#8220;apply.&#8221;</p>
</li><li id="comment-190"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_190'); }"  onmouseout="Element.hide('admin_comment_190');" >
  <div id="admin_comment_190" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/190', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-190',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/190" class="admintools">edit</a></div>
  <a name="comment-190"></a>
  
  <cite><strong>Notav A.</strong> </cite> said 191 days later:<br />
  <p>(apply (lambda (a b) (+ a b)) &#8216;(1 2))</p>


	<p>can be done with:</p>


	<p>lambda{|a,b| a+b}.call(*[1,2])</p>
</li><li id="comment-192"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_192'); }"  onmouseout="Element.hide('admin_comment_192');" >
  <div id="admin_comment_192" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/192', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-192',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/192" class="admintools">edit</a></div>
  <a name="comment-192"></a>
  
  <cite><strong><a href="http://null">someone</a></strong> </cite> said 202 days later:<br />
  <p>Do Lisp coders write programs or do they just sit around talking about their language?</p>


	<p>It seems to be in use deep within the halls of CS departments and AI research, but in years and years of working with software, managing systems, writing for more OSes and problem domains than I can keep track of, I haven&#8217;t encountered a scrap of Lisp code or even a similar project to my own in which someone was using Lisp.  I don&#8217;t mean to flame, but I&#8217;ve seen roughly a thousand times more talking about Lisp than the using of it.</p>


	<p>I&#8217;ve always meant to learn Lisp, but I get the sense that I&#8217;ll be applying the knowledge more on usenet than on actual programs.</p>


	<p>I&#8217;ve recently discovered Ruby, and of all its amazing strengths ( I&#8217;ll put at the top of the list <del>- at least as far as something that you&#8217;ll probably see on any open vim session on my workstation these days -</del> is the enumerable module ) nothing quite matches the friendliness and helpfulness of its community.  Ruby seems to be the first language to really get that languages are software and programmers are users.</p>


	<p>Programming communities need collective nouns.  An obfuscation of Perl hackers.  A stalwart of C coders.  A furrow of assembly wranglers.  An effusing of Ruby hackers.  An ulcer of <span class="caps">CSS</span> authors.  A grumbling of Lisp coders.</p>
</li><li id="comment-193"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_193'); }"  onmouseout="Element.hide('admin_comment_193');" >
  <div id="admin_comment_193" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/193', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-193',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/193" class="admintools">edit</a></div>
  <a name="comment-193"></a>
  
  <cite><strong>Eric</strong> </cite> said 204 days later:<br />
  <p>I suppose it depends on your geographic location: I&#8217;ve spent at least 6 of the last 10 years working with Lisp and Scheme on both academic and commercial projects. But then again, I like to work on cool, offbeat stuff, and I live in the greater Boston area&#8212;two factors which, together, correlate highly with Lisp.</p>


	<p>If you&#8217;ve been working in AI, and you&#8217;ve never seen Lisp, the odds are extremely good that your work started after the late 80s. That&#8217;s when a combination of Moore&#8217;s Law and gross business incompetence killed off half the Lisp companies.</p>


	<p>Nonetheless, you should probably learn Lisp if you want to take full advantage of Ruby: The book <em>Practical Common Lisp</em> contains 10 times as much meta-programming advice as all the Ruby documentation I&#8217;ve seen, combined.</p>
</li><li id="comment-199"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_199'); }"  onmouseout="Element.hide('admin_comment_199');" >
  <div id="admin_comment_199" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/199', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-199',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/199" class="admintools">edit</a></div>
  <a name="comment-199"></a>
  
  <cite><strong>William James</strong> </cite> said 264 days later:<br />
  <p>Here are some Ruby equivalents of some Lisp examples:</p>


<pre>
(iter (for x in '(-1 2 -10 4))
      (finding x maximizing (abs x)))
</pre>

<pre>
[-1, 2, -10, 4].inject{|a,b| a.abs &gt; b.abs ? a : b}
# or
[-1, 2, -10, 4].sort_by{|n| n.abs}.last
</pre>

<pre>
(iter (for x in '(1 2 3 -4 -10 -43 49 49 8934))
         (until (= (sqrt 7) x))
         (collect x into collection)
         (finding x maximizing (abs x) into y)
         (finally (return (list collection y))))
</pre>
(By the way, I don&#8217;t think this Lisp will work as advertised. (= (sqrt 7) x) seems wrong.)

<pre>
def maxim a,b; (yield a) &gt; (yield b) ? a : b; end
y = 0
[1,2,3,-4,-10,-43,49,49,8934].inject([]){|a,n|
  break [a,y]  if n==49
  y = maxim(y,n){|x| x.abs}
  a &lt;&lt; n }
</pre>
</li><li id="comment-200"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_200'); }"  onmouseout="Element.hide('admin_comment_200');" >
  <div id="admin_comment_200" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/200', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-200',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/200" class="admintools">edit</a></div>
  <a name="comment-200"></a>
  
  <cite><strong>William James</strong> </cite> said 265 days later:<br />
  This version will work properly even if the list doesn&#8217;t contain 49; also, the variable y has been eliminated.
<pre>
def maxi a,b; (yield a) &gt; (yield b) ? a : b; end
[1,2,3,-4,-10,-43,49,49,8934].inject([[],0]){|a,n|
  break a  if n==49
  a[1] = maxi(a[1],n){|x| x.abs}
  a[0] &lt;&lt; n ; a }
</pre>
</li><li id="comment-201"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_201'); }"  onmouseout="Element.hide('admin_comment_201');" >
  <div id="admin_comment_201" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/201', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-201',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/201" class="admintools">edit</a></div>
  <a name="comment-201"></a>
  
  <cite><strong>Miquel</strong> </cite> said 278 days later:<br />
  <p>I have to say that I work with lisp everyday and it is very powerful. I just haven&#8217;t got the motivation to make a decent interface to mysql for my web applications. That is why I chose Rails.</p>


	<p>Oh Well..</p>


	<p>However, when the db support arrives, I am going back.</p>
</li><li id="comment-202"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_202'); }"  onmouseout="Element.hide('admin_comment_202');" >
  <div id="admin_comment_202" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/202', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-202',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/202" class="admintools">edit</a></div>
  <a name="comment-202"></a>
  
  <cite><strong>Pebblestone</strong> </cite> said 278 days later:<br />
  <p>Miquel:</p>


	<p>Try <span class="caps">CLSQL</span>, it supports multiple DBs and on multiple lisp implementations. And I just used it in my last project.</p>
</li><li id="comment-205"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_205'); }"  onmouseout="Element.hide('admin_comment_205');" >
  <div id="admin_comment_205" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/205', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-205',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/205" class="admintools">edit</a></div>
  <a name="comment-205"></a>
  
  <cite><strong>KristofU</strong> </cite> said 296 days later:<br />
  <p>I&#8217;m a C++ programmer, and was looking for a new language to learn and do stuff more elegantly.
Ruby just sucked me right in. There is almost nothing to learn, it&#8217;s just there.
You can slice and dice and juggle and the result is always a working program.
You like for-statements? Well, you can use for-statements. You like iterators? Well, you can use iterators. Make object functors or lambda&#8217;s, whichever you prefer. Ruby doesn&#8217;t force anything upon you, there is time to learn to appreciate the finer features, while still churning out working apps in the meantime.
I&#8217;ve also briefly tried Haskell, Scheme and Erlang, but I have to say, I couldn&#8217;t get anything done. Compared to Ruby, quite an anti-climax.</p>
</li><li id="comment-207"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_207'); }"  onmouseout="Element.hide('admin_comment_207');" >
  <div id="admin_comment_207" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/207', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-207',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/207" class="admintools">edit</a></div>
  <a name="comment-207"></a>
  
  <cite><strong><a href="http://t-a-w.blogspot.com/">taw</a></strong> </cite> said 302 days later:<br />
  <p>You might be interested in <a href="http://t-a-w.blogspot.com/2006/07/rlisp-lisp-naturally-embedded-in-ruby.html" rel="nofollow">RLisp</a>, which is Lisp directly connected to Ruby runtime and very tightly integrated with Ruby.</p>


	<p>It is very alpha, but can do really cool stuff like <a href="http://t-a-w.blogspot.com/2006/07/rlisp-gets-http-support.html" rel="nofollow"><span class="caps">HTTP</span> server</a> that uses webrick (from standard Ruby library) and macros.</p>


	<p>I think even at this early stage it is probably one of the most practical Lisps for scripting-style of programs, due to access to all Ruby libraries.</p>


	<p>The biggest problem right now seems to be culture shock, as RLisp has Ruby/Python-style let (this is the most controversial part, I don&#8217;t have any idea why), a &#8220;real&#8221; object system (based on message passing and everything-is-a-Ruby-object), and lists are arrays (so cdr/cons copy).</p>


	<p>Enjoy :-)</p>
</li><li id="comment-208"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_208'); }"  onmouseout="Element.hide('admin_comment_208');" >
  <div id="admin_comment_208" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/208', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-208',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/208" class="admintools">edit</a></div>
  <a name="comment-208"></a>
  
  <cite><strong>Simplicus</strong> </cite> said 304 days later:<br />
  <p>Why compare Ruby with Lisp and not with Erlang, Haskell or ML or other FP languages?</p>


	<p>I find this discussion very fruitful in many aspects. Yet the most interesting part of it for me personally is to what extent Ruby is a functional language?  Or using Eric terminology how “functionally dense” Ruby really is?</p>


	<p>I have no doubts that Lisp and Scheme in particular can be used for functional programming (FP). Nevertheless both of these languages can be used equally well for non-functional programming also.</p>


	<p>Now back to my question: 
Why compare Ruby with Lisp and not with Erlang, Haskell or ML, or other “true” (Haskell) or “more functional” (Erlang, ML) FP languages?</p>


	<p>I understand that from the above mentioned FP languages only Erlang has no strict types and two others (Haskell and ML) are strict. Nevertheless, I think that we can still compare “functional density” of those with Ruby’s.</p>


	<p>I have 20+ years of programming experience, starting with <span class="caps">DEC PDP</span>-11 Macro Assembler and most of later work in <span class="caps">OOP</span>, such as C+ and then Java which I started to play with its first alpha release. That time I liked Java a lot compared to C++. During that “old times” I had also a chance to get to know <span class="caps">CLOS</span> and was charmed with its powerful ideas (lists = code = data, generic functions, <span class="caps">MOP</span>, to name a few), uniformity and simplicity. Unfortunately, that time (and today as well) I couldn’t find a way to do my living working on Lisp or Scheme projects, though I did some work in AI related areas (and learned many other “small” and “big” languages including Prolog) .</p>


	<p>About three years ago I started to research FP quite seriously, trying to find programming tools (languages) more powerful then Java and other <span class="caps">OOP</span> languages that I could use to implement some of the ideas waiting in silo quite for a long time already.</p>


	<p>I started with Scheme, then ML and now Haskell which I like most for its clarity and power. In between I am looking at Erlang and Ruby. Returning back to “FP density” Scheme and Lisp lack some powerful constructs that ML and Haskell have and that I find very important for uniformity, clarity, readability and expressiveness of the language. (Mind you, I love them all Haskell, Scheme and Lisp :)</p>


	<p>These things are:</p>


	<p>1) Guards (Haskell)</p>


	<p>2) Pattern matching (Haskell, ML, Erlang)</p>


	<p>3) List comprehensions (Haskell)</p>


	<p>Guards example:</p>


<pre>
max :: Int -&gt; Int -&gt; Int
max x y
    | x &gt;=y     = x
    | otherwise    = y

</pre>

	<p>Example of both pattern matching and comprehensions &#8211; quick sort in Haskell is simple as that:</p>


<pre>
qSort :: [Int] -&gt; [Int] 
qSort [] = []
qSort (x:xs) = 
  qSort [ y | y &lt;-xs, y&lt;=x] ++ [x] ++ qSort [ y | y&lt;-xs, y &gt; x]
</pre>

	<p>This code is very close to informal definition of quick sort:</p>


	<p>“To sort the list take off the head ‘(x:xs)’ and then split the result in two parts: the first containing the elements no larger then ‘x’ and the second exceeding ‘x’. Sort these two parts and then concatenate ‘x’ with results of these two sorts”</p>


	<p>Isn’ it clarity and readability?</p>


	<p>Isn’t purely functional notation is better then a notaion produced by macros?</p>


	<p>What Ruby gives as equivalent to Guards, Pattern matching and List comprehensions?</p>


	<p>I am not even talking about extremely powerful strategy of lazy evaluation that allows Haskell only evaluate a function argument when it is really needed (on demand) to compute the overall result. This in turn makes computations less expensive and allows language to describe infinite data structures.</p>


	<p>As almost everything else, lazy evaluation can be implemented in Lisp and Scheme. Any ideas how to do this in Ruby?</p>


	<p>After Haskell, Ruby syntax looks too eclectic for me (<code>foo, </code>@bar, baz  :faz =&gt; xxx), ‘blocks’ and ‘yields’ makes me feel sorry for functions as first class objects, “meta programming” seems for me to be a perfect tool to hide and obscure what is really going on behind the code I see right now (because methods can be added to classes in other source files),  etc…</p>


	<p>Maybe I am totally wrong about Ruby and will drastically change my opinion after more experience with it, we’ll see.</p>


	<p>As for this discussion it would be interesting to know what you guys think about:</p>


	<p>1) The question I started this message with</p>


	<p>2) Why Haskell (and FP in general) is not as widespread as Java, Python &#38; Ruby? And all these sad things are happening in spite of:</p>


	<p>a. Though not so big but very strong and dedicated community of Haskell developers.</p>


	<p>b. Constantly growing set of open source Haskell applications, tools and libraries.</p>
</li><li id="comment-209"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_209'); }"  onmouseout="Element.hide('admin_comment_209');" >
  <div id="admin_comment_209" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/209', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-209',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/209" class="admintools">edit</a></div>
  <a name="comment-209"></a>
  
  <cite><strong><a href="http://null">schemer</a></strong> </cite> said 320 days later:<br />
  <p>Simplicus, I would agree that pattern matching and guards are awesome, even in the absense of types.</p>


	<p>I mainly code in Scheme, but I was absolutely blown away by Monads and lazy evaluation when I tried Haskell.  I can&#8217;t belive most programmers consider those aspects of Haskell a turn off, both are techniques which I was earlier trying to reinvent while programming in Scheme while not even realizing it.</p>


	<p>However, from personal experience, I would have to note that there is no reason why scheme can&#8217;t have those features; (There are libraries for pattern matching as you presumed, and there are</p>


	<p>As for what I think makes scheme less &#8220;functionally dense&#8221; than Haskell are:</p>


	<p>Scheme&#8217;s mutable define, mutable cons, and non-imperative i/o are what make it less functional than Haskell.  Of course, these features that I mentioned aren&#8217;t really fundamental properties of the language, both in my opinion are historical cruft that I hope someday will be fixed&#8230;</p>


	<p>On the other hand, I&#8217;d <em>love</em> to see a sexpr Haskell. :)</p>


	<p>As for ruby, I don&#8217;t consider it to be &#8220;functional,&#8221; (although I wouldn&#8217;t be surpised if ruby programmers were fond of hofs) because as far as I know, it doesn&#8217;t have tail-call optimization.  With Common Lisp, even though it doesn&#8217;t have tco, every major compiler out there (CMUCL, <span class="caps">SBCL</span>, probably also CLisp) optimizes tail calls, so I have no particular problem with CL, assuming a very non-idiomatic style to CL.</p>


	<p><span class="caps">TCO</span> is a big deal for me, because in Elisp I have to use destructive maps/filters to avoid exceeding the functional call depth, that&#8217;s really annoying&#8230;</p>
</li><li id="comment-210"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_210'); }"  onmouseout="Element.hide('admin_comment_210');" >
  <div id="admin_comment_210" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/210', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-210',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/210" class="admintools">edit</a></div>
  <a name="comment-210"></a>
  
  <cite><strong><a href="http://null">schemer</a></strong> </cite> said 320 days later:<br />
  <p>Argh.  I made some bad typos to my post: I meant <em>lack of</em> non-imperative i/o in my prior statement.</p>


	<p>Also, I forgot to note several prominent scheme hackers have implemented monads in scheme, though unfortunately there&#8217;s no standardized example&#8230;</p>


	<p>Lazy evaluation in scheme is also doable as you mentioned, even though I haven&#8217;t yet gottten the srfi for stream-define and friends working properly (apparently the my implementations&#8217; modules are not compatable with it without extra macros)</p>


	<p>I also don&#8217;t grasp why the srfi for memoized streams uses set! when it could just use a helper function (but then again, I would say that this is a problem of mutable define in scheme)</p>
</li><li id="comment-212"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_212'); }"  onmouseout="Element.hide('admin_comment_212');" >
  <div id="admin_comment_212" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/212', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-212',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/212" class="admintools">edit</a></div>
  <a name="comment-212"></a>
  
  <cite><strong>William James</strong> </cite> said 325 days later:<br />
  Quicksort in Ruby:
<p><pre>
def qsort ary
  return ary  if ary == []
  pivot = ary[0]
  left, right = ary[1..-1].partition{|x| x &lt; pivot }
  qsort( left ) + [pivot] + qsort( right )
end
</pre></p>
</li><li id="comment-213"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_213'); }"  onmouseout="Element.hide('admin_comment_213');" >
  <div id="admin_comment_213" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/213', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-213',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/213" class="admintools">edit</a></div>
  <a name="comment-213"></a>
  
  <cite><strong>memeplex</strong> </cite> said 325 days later:<br />
  <p>Lack of community and codebase are strong impediments for every but a few language. Also most new languages are missing a standard ffi which let them easily access c/c++ legacy code, preferable via bindings autogenerated by tools like swig. In this regard, Lisp has cffi, which is a good thing. But anyway, you won&#8217;t get too far away without people doing the heavy lifting, all that enormous amount of binding code should be generated, patched and tested. It seems like the way to go for small communities is to parasite mature and well established runtimes, and to compile to their intermediate binary representation. Of course I&#8217;m talking of java and .net/mono/pnet here. They&#8217;re doing their thing pretty well, performance is more than acceptable, and taken as intermediate languages (which msil is more than java bytecode) they can even be compiled to native code (take for example gcj). I love scheme programming but I&#8217;m also fond of new oo+fp languages, namely scala or nemerle. Because of the reflection capabilities of this cross-language/cross-platform runtimes, binding is far easier than it is for C/C++ native stuff. Sometimes it&#8217;s just a matter of importing modules and start using them. Admittedly, a generic runtime it&#8217;s not the same than a standard library tailored to an specific language. But then those standard libraries could be build faster on top of the facilities offered by the runtime, and in case they are still not complete, one can always resort to the generic api, it&#8217;s not a cul-de-sac. Also you can easily bind to c/c++ if you really need it: there are mature swig modules for java and c#, while there aren&#8217;t others for a lot of cool, tiny languages. I&#8217;m currently programming in bigloo scheme targeting the jvm, and in scala too (they both are able to generate code for the clr also, although support isn&#8217;t that mature already). I think it&#8217;s the way to go for languages with small communities. And in any case, these intermediate platforms promote code reuse, offer advanced interpretation/compilation techniques (while there could be lack of support for specific techniques, like tail-recursion, that&#8217;s a price to pay), powerful development environments, etc etc. Just how I&#8217;m feeling like lately.</p>
</li><li id="comment-214" class="author_comment"  onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_214'); }"  onmouseout="Element.hide('admin_comment_214');" >
  <div id="admin_comment_214" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/214', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-214',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/214" class="admintools">edit</a></div>
  <a name="comment-214"></a>
  
  <cite><strong>Eric Kidd</strong> </cite> said 326 days later:<br />
  <p>Oh, I&#8217;m a huge fan of Haskell. The syntax is nice and dense (though occasionally a bit alien), and monads are a remarkably powerful abstraction.</p>


	<p>There&#8217;s a whole class of designs which can be easily expressed with monads (unification, backtracking, transactions, continuations-as-a-library, localized state, modular parsers, and so on). A lot of these designs can&#8217;t be implemented cleanly with Lisp macros (unless you write a code-walker, or an entire embedded language).</p>


	<p>It also seems that monads are most useful when you can have more than one of them, and when you can overload your monadic operations depending on the return type of your function. This is the biggest barrier I&#8217;ve found to using monadic code in Scheme.</p>


	<p>Haskell is a fairly <em>hard</em> programming language, and I doubt it will ever go mainstream. But it&#8217;s by far one of the most interesting languages on the scene, and I learn a lot programming in it. My biggest complaint is the lack of subtyping, which is fixed by O&#8217;Haskell.</p>


	<p>If I had to recommend four languages to learn, I&#8217;d recommend Ruby (because it&#8217;s so fun), Lisp/Scheme (for the macros), Oz (for unification, concurrent logic and constraints) and Haskell (for monads and for the deeply mathematical style).</p>
</li><li id="comment-224"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_224'); }"  onmouseout="Element.hide('admin_comment_224');" >
  <div id="admin_comment_224" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/224', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-224',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/224" class="admintools">edit</a></div>
  <a name="comment-224"></a>
  
  <cite><strong>scripting geek</strong> </cite> said 374 days later:<br />
  <p>Very interesting and enjoyable discussion!</p>


	<p>I did <span class="caps">LISP</span> and Scheme for a few years in the early 90s, doing AI at Berkeley.  Looking back over that code some years later, just for fun, I was struck by the total impenetrability of my earlier <span class="caps">LISP</span> excretions.  The resulting tangle of sexp was so nasty, I would have opted for ritual seppuku if required to decipher the stuff.  But that&#8217;s just me and my substandard <span class="caps">LISP</span> code.</p>


	<p>On another tangent..  I&#8217;m finding the impassioned arguments about language properties very interesting, but ultimately somewhat irrelevant, at least insofar as productivity is concerned.</p>


	<p>I think that nowadays the breadth and quality of the available open source libraries is a much larger factor in the appeal of a language as a useful tool than are the theoretical upper limits of its expressive capability.</p>


	<p>Learning to live with somewhat clunky metaprogramming facilities as opposed to super-powerful macros is infinitely easier, I think, than lacking libraries for half the stuff you need done on a daily basis.</p>


	<p>It sounds as though <span class="caps">LISP</span> is still far behind the Python/Ruby camps insofar as that&#8217;s concerned, and for this reason alone I wouldn&#8217;t give it another look at this time.  And, at least in my case, I learned that power of program-as-AST that&#8217;s so nice for computers is not so good for human comprehension, as we do not make good recursive tree evaluators.  Beyond a modest level of nesting and layering, things start to look very nasty indeed.</p>


	<p>Python/Ruby on the other hand are very readable, with plenty of useful idioms captured by grammar or sugar, and have APIs to easily interact with just about everything.  With tools such as these, I alone can replace a small department of C programmers, and that&#8217;s very appealing.</p>
</li><li id="comment-225"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_225'); }"  onmouseout="Element.hide('admin_comment_225');" >
  <div id="admin_comment_225" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/225', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-225',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/225" class="admintools">edit</a></div>
  <a name="comment-225"></a>
  
  <cite><strong><a href="http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages">Chris Rathman</a></strong> </cite> said 406 days later:<br />
  <p>Since the topic is a comparison between Ruby and Lisp (and Simplicus expressed an interest in comparing Ruby with Haskell or ML or other FP languages), I thought I&#8217;d mention my pet project to translate the <span class="caps">SICP</span> examples into these languages.</p>


	<p>http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages</p>


	<p>I&#8217;ve still got a lot to learn about Ruby, but in translating the first chapter and a half the main quirks I had with Ruby were (1) it&#8217;s lack of Tail Call Optimization &#8211; an attibute shared with Python and JavaScript (many in the Lisp community consider the lack of <span class="caps">TCO</span> to be a bug); and (2) the distinction between named and anonymous functions.  As far as I can tell, you can curry lambdas, but you can&#8217;t curry named functions &#8211; Erlang works this way as well.</p>
</li><li id="comment-226"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_226'); }"  onmouseout="Element.hide('admin_comment_226');" >
  <div id="admin_comment_226" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/226', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-226',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/226" class="admintools">edit</a></div>
  <a name="comment-226"></a>
  
  <cite><strong>gar37bic</strong> </cite> said 407 days later:<br />
  <p>This is a great discussion, and has been very informative for me.  I&#8217;m thinking about which language I want to tackle next, primarily for research into areas such as neural networks.</p>


	<p>In my real life, I spend a lot of time writing heuristic filters based on regular expressions &#8211; (typically using <span class="caps">PCRE</span>: &#8216;perl-compatible regex&#8217;, though I don&#8217;t use Perl) &#8211; to do things like parse, filter, sanitize and combine multiple legacy datasets into one &#8216;canonical&#8217; set.  This often requires running other programs to pre-sort incoming data streams, and then maintaining arrays of match-probability scores for possible matches.  How would these languages address problems such as these?</p>
</li><li id="comment-227"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_227'); }"  onmouseout="Element.hide('admin_comment_227');" >
  <div id="admin_comment_227" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/227', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-227',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/227" class="admintools">edit</a></div>
  <a name="comment-227"></a>
  
  <cite><strong>gar37bic</strong> </cite> said 407 days later:<br />
  <p>I also often &#8216;scrape&#8217; (with permission) <span class="caps">HTML</span>, SQL, <span class="caps">CVS</span>, PDF, <span class="caps">DOC</span> and other files off the net, to generate input data for our company&#8217;s data mining operation, for example corporate federal and <span class="caps">SEC</span> filings.</p>


	<p>And right now I&#8217;m scripting OpenOffice to do file format conversions to .DOC &#8230;</p>
</li><li id="comment-228"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_228'); }"  onmouseout="Element.hide('admin_comment_228');" >
  <div id="admin_comment_228" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/228', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-228',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/228" class="admintools">edit</a></div>
  <a name="comment-228"></a>
  
  <cite><strong>Eric Kidd</strong> </cite> said 407 days later:<br />
  <p>Chris Rathman: <i>I thought I’d mention my pet project to translate the <span class="caps">SICP</span> examples into these languages.</i></p>


	<p>Oh, that&#8217;s really cool.  Thanks for the link!</p>
</li><li id="comment-229"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_229'); }"  onmouseout="Element.hide('admin_comment_229');" >
  <div id="admin_comment_229" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/229', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-229',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/229" class="admintools">edit</a></div>
  <a name="comment-229"></a>
  
  <cite><strong>David A. Wheeler</strong> </cite> said 407 days later:<br />
  <p>One problem with traditional Lisp notation is that it&#8217;s fairly hard to read&#8212;and as programs get bigger, it gets worse.   It&#8217;s especially nasty when you use operators that are traditionally infix operators, e.g., (+ 3 (* 2 3)) may be a regular syntax, but even Graham admits it&#8217;s awkward.</p>


	<p>I&#8217;ve developed a notation called &#8220;sweet-expressions&#8221; which I think are easier to read.  A sweet-expression readers can read normal s-expressions, but can also accept other formats. It still works with all the macro constructs, etc., of Lispy languages.  More info is here:
<a href="http://www.dwheeler.com/readable/" rel="nofollow">http://www.dwheeler.com/readable/</a></p>
</li><li id="comment-233"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_233'); }"  onmouseout="Element.hide('admin_comment_233');" >
  <div id="admin_comment_233" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/233', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-233',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/233" class="admintools">edit</a></div>
  <a name="comment-233"></a>
  
  <cite><strong>A Total Coward</strong> </cite> said 410 days later:<br />
  <p>bill a: your links to LoaL are all 404s. Did this stuff every see any daylight?</p>
</li><li id="comment-234"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_234'); }"  onmouseout="Element.hide('admin_comment_234');" >
  <div id="admin_comment_234" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/234', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-234',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/234" class="admintools">edit</a></div>
  <a name="comment-234"></a>
  
  <cite><strong><a href="http://thelittlenook@blogspot.com">Timmy Jose</a></strong> </cite> said 410 days later:<br />
  <p>For a programmer used to C/C++ and <span class="caps">JAVA</span> and having merely studied the rudimentaries of Lisp in college ( as part of A.I ) and having had to content myself by looking at Ruby from the sidelines till now, I found this thread extremely interesting. It was all a bit one-sided though with Lispers outnumbering Rubyists (?) by a huge ratio! In my opinion, the syntax of Lisp seemed to be more in tune with my liking than Ruby&#8217;s. I think I&#8217;ll take the plunge with Lisp and see where Ruby fits in later. Good job on the discussion people!</p>
</li><li id="comment-544"   onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_comment_544'); }"  onmouseout="Element.hide('admin_comment_544');" >
  <div id="admin_comment_544" style="display: none"><a class="admintools" href="#" onclick="if (confirm('Are you sure you want to delete this comment?')) { new Ajax.Request('/articles/nuke_comment/544', {asynchronous:true, evalScripts:true, onComplete:function(request){new Effect.Puff('comment-544',{duration:0.6});}}); }; return false;">nuke</a><a href="/admin/comments/article/77/edit/544" class="admintools">edit</a></div>
  <a name="comment-544"></a>
  
  <cite><strong>Charlie Lindahl</strong> </cite> said 740 days later:<br />
  <p>I worked for a number of years on <span class="caps">LISP</span> machines at Texas Instruments in the 80s</p>


	<p>One of my points is : it&#8217;s the environment. Not just the <span class="caps">IDE</span>; in <span class="caps">LISP</span> and Smalltalk environments <span class="caps">EVERYTYHING</span> is written in the language in
question/use (with the exception of machine-specific low-level stuff
required to talk to the OS / machine architecture).</p>


	<p>What this means (not great for a general business case, but incredible for learning and expressive power) is that I can actually take apart / customize / study the underlying OS and/or tools.</p>


	<p>So, for example, say you don&#8217;t like the way <span class="caps">EMACS</span> works. Go grab the source (a keystroke away in <span class="caps">LISP</span> IDEs) and go plowing through it with
 the IDEs/debuggers and rewrite it to your specifications.</p>


	<p>I learned the Macintosh Toolbox structure by running Lisp on the Mac
and dissecting the window data structures (on the fly / realtime )
without needing to have source code.</p>


	<p>Once Ruby gets to the point of this kind of power in the environment,
inspection, and debugging it&#8217;ll be amazingly powerful.</p>


	<p>Quite good now from what I&#8217;ve seen so far.</p>


	<pre><code>My $.02</code></pre>


	<pre><code>Charlie Lindahl
Houston, TX</code></pre>
</li>
  
  </ol>


<p class="postmetadata alt">
  <small>
  <a href="http://www.randomhacks.net/xml/rss20/article/77/feed.xml" title="RSS Feed">RSS feed for this post</a>
  <a href="http://www.randomhacks.net/articles/trackback/77" >trackback uri</a>  
  </small>
</p>

  <p>Comments are disabled</p>

          <script type="text/javascript">
//<![CDATA[
show_dates_as_local_time()
//]]>
</script>
        </div>
        
        <div id="sidebar">
          
            <div id="search-results"></div>
            
              
      
      <div class="sidebar-node">
        <h3>About the author</h3>
<img src="/files/headshot.jpg" align="right" alt="Photo of Eric" width="48" height="48" />

<p>Eric Kidd lives in Vermont, where he works as the lead programmer on a 2D/3D multimedia engine.</p>

<p>He's into compilers, robotics, and programming language design. He's an unapologetic Lisp geek, and has recently been trying to port his favorite Lisp macros to Ruby.</p>

<p><a href="/contact/" title="Contact Eric Kidd">Contact the author</a></p>

      </div>
    
      
      <div class="sidebar-node">
        <h3>Recommended Reading</h3>
<ul class="tagged_articles">
  <li><a href="/articles/2007/02/22/bayes-rule-and-drug-tests">Bayes' rule in Haskell, or why drug tests don't work</a></li>
  <li><a href="/articles/2007/02/10/map-fusion-and-haskell-performance">Map fusion: Making Haskell 225% faster</a></li>
  <li><a href="/articles/2005/12/03/why-ruby-is-an-acceptable-lisp">Why Ruby is an acceptable LISP</a></li>
  <li><a href="/articles/2005/10/11/amb-operator">McCarthy's Ambiguous Operator</a></li>
  <li><a href="/articles/2003/06/22/the-missing-future">The Missing Future</a></li>
  <li><a href="/articles/2002/11/10/ll2">Lightweight Languages 2 Conference</a></li>
  <li><a href="/articles/2002/09/29/bayesian-whitelisting">Bayesian Whitelisting: Finding the Good Mail Among the Spam</a></li>
</ul>

      </div>
    
      
      <div class="sidebar-node">
        <div class="tags">
<h3>Tags</h3>
<p style="overflow:hidden">
<span style="font-size:86.2068965517241%"><a href="/articles/tag/Garden">Garden</a></span>
<span style="font-size:17.2413793103448%"><a href="/articles/tag/Git">Git</a></span>
<span style="font-size:155.172413793103%"><a href="/articles/tag/Hacks">Hacks</a></span>
<span style="font-size:310.344827586207%"><a href="/articles/tag/Haskell">Haskell</a></span>
<span style="font-size:34.4827586206897%"><a href="/articles/tag/JavaScript">JavaScript</a></span>
<span style="font-size:34.4827586206897%"><a href="/articles/tag/LISP">LISP</a></span>
<span style="font-size:34.4827586206897%"><a href="/articles/tag/Mac">Mac</a></span>
<span style="font-size:68.9655172413793%"><a href="/articles/tag/Macros">Macros</a></span>
<span style="font-size:206.896551724138%"><a href="/articles/tag/Math">Math</a></span>
<span style="font-size:189.655172413793%"><a href="/articles/tag/Monads">Monads</a></span>
<span style="font-size:34.4827586206897%"><a href="/articles/tag/Performance">Performance</a></span>
<span style="font-size:189.655172413793%"><a href="/articles/tag/Probability">Probability</a></span>
<span style="font-size:68.9655172413793%"><a href="/articles/tag/Rails">Rails</a></span>
<span style="font-size:155.172413793103%"><a href="/articles/tag/Recommended">Recommended</a></span>
<span style="font-size:17.2413793103448%"><a href="/articles/tag/Robots">Robots</a></span>
<span style="font-size:120.689655172414%"><a href="/articles/tag/Ruby">Ruby</a></span>
<span style="font-size:172.413793103448%"><a href="/articles/tag/Spam">Spam</a></span>
<span style="font-size:34.4827586206897%"><a href="/articles/tag/Typo">Typo</a></span>
<span style="font-size:17.2413793103448%"><a href="/articles/tag/Web">Web</a></span>
<span style="font-size:34.4827586206897%"><a href="/articles/tag/wxWidgets">wxWidgets</a></span>
</p>
</div>


      </div>
    
      
      <div class="sidebar-node">
        <h3>Recent Comments</h3>
<ul id="recent_comments">
  <li><a href="/articles/2008/09/01/ubiquitous-hoogle#comment-605">Neil Mitchell on Ubiquitous Hoogle</a></li>
  <li><a href="/articles/2009/01/11/installing-tortoisegit#comment-604">guan on Installing TortoiseGit</a></li>
  <li><a href="/articles/2007/03/07/hefferon-linear-algebra-review#comment-600">Anand on Jim Hefferon's Linear Algebra: A free textbook with fascinating applications</a></li>
  <li><a href="/articles/2007/03/07/hefferon-linear-algebra-review#comment-599">Anand on Jim Hefferon's Linear Algebra: A free textbook with fascinating applications</a></li>
  <li><a href="/articles/2008/09/01/ubiquitous-hoogle#comment-596">Henri Losoi on Ubiquitous Hoogle</a></li>
  <li><a href="/articles/2007/04/28/bowling-in-haskell#comment-595">Seth Tisue on Bowling in Haskell: A response to Ron Jeffries</a></li>
  <li><a href="/articles/2007/03/07/hefferon-linear-algebra-review#comment-587">Anon on Jim Hefferon's Linear Algebra: A free textbook with fascinating applications</a></li>
  <li><a href="/articles/2007/09/18/just-married#comment-585">rajika on September 8th, 2007</a></li>
  <li><a href="/articles/2005/10/11/amb-operator#comment-583">backtrack on McCarthy's Ambiguous Operator</a></li>
  <li><a href="/articles/2008/09/01/ubiquitous-hoogle#comment-582">Bryan O'Sullivan on Ubiquitous Hoogle</a></li>
</ul>

      </div>
    
      
      <div class="sidebar-node">
        <h3>Programming Links</h3>
<ul>
  <li><a href="http://lambda-the-ultimate.org/" title="CS theory geeking">&lambda; the Ultimate</a></li>
  <li><a href="http://planet.haskell.org" title="Many Haskell blogs">Planet Haskell</a></li>
  <li><a href="http://planet.lisp.org/" title="Many Lisp blogs">Planet Lisp</a></li>
  <li><a href="http://www.planeterlang.org/" title="Many Erlang blogs">Planet Erlang</a></li>
  <li><a href="http://planetruby.0x42.net/" title="Many Ruby blogs">Planet Ruby</a></li>
  <li><a href="http://cgi.cse.unsw.edu.au/~dons/blog" title="Practical Haskell">dons</a></li>
  <li><a href="http://sigfpe.blogspot.com/" title="Really theoretical Haskell">sigfpe</a></li>
  <li><a href="http://trevion.blogspot.com/" title="Haskell meets reality">Nonlinear</a></li>
  <li><a href="http://eigenclass.org/" title="Ruby metaclass hackery">Eigenclass</a></li>
  <li><a href="http://weblog.rubyonrails.org/" title="Ruby on Rails">Riding Rails</a></li>
  <li><a href="http://www.loudthinking.com/" title="Author of Ruby on Rails">Loud Thinking</a></li>
  <li><a href="http://weblog.raganwald.com/" title="Java software development from a Lisp perspective">Raganwald</a></li>
  <li><a href="http://www.paulgraham.com/articles.html" title="Essays on Lisp and startups">Paul Graham</a></li>
  <li><a href="http://programming.reddit.com/" title="Programming news">programming reddit</a></li>
  <li><a href="http://silkandspinach.net/" title="Agile development and lean manufacturing">silk and spinach</a></li>
</ul>


      </div>
    
      
      <div class="sidebar-node">
        <h3>Math Links</h3>
<ul>
  <li><a href="http://scienceblogs.com/goodmath/">Good Math, Bad Math</a></li>
  <li><a href="http://carnivalofmathematics.wordpress.com/">Carnival of Mathematics</a></li>
  <li><a href="http://blog.mikael.johanssons.org/">Michi’s blog</a></li>
</ul>

      </div>
    
      
      <div class="sidebar-node">
        
<h3>Archives</h3>
<ul id="archives">
  
    <li>
      <a href="/articles/2009/01">January 2009</a>
      <em>(1)</em>
    </li>
  
    <li>
      <a href="/articles/2008/09">September 2008</a>
      <em>(1)</em>
    </li>
  
    <li>
      <a href="/articles/2007/10">October 2007</a>
      <em>(1)</em>
    </li>
  
    <li>
      <a href="/articles/2007/09">September 2007</a>
      <em>(2)</em>
    </li>
  
    <li>
      <a href="/articles/2007/07">July 2007</a>
      <em>(1)</em>
    </li>
  
    <li>
      <a href="/articles/2007/04">April 2007</a>
      <em>(2)</em>
    </li>
  
    <li>
      <a href="/articles/2007/03">March 2007</a>
      <em>(6)</em>
    </li>
  
    <li>
      <a href="/articles/2007/02">February 2007</a>
      <em>(10)</em>
    </li>
  
    <li>
      <a href="/articles/2007/01">January 2007</a>
      <em>(2)</em>
    </li>
  
    <li>
      <a href="/articles/2006/02">February 2006</a>
      <em>(1)</em>
    </li>
  
</ul>


      </div>
    
      
      <div class="sidebar-node">
        <h3>Syndicate</h3>
<ul>
    <li><a href="/xml/rss20/feed.xml" title="Articles feed">Articles</a></li>
  
    <li><a href="/xml/rss20/comments/feed.xml" title="Comments feed">Comments</a></li>
  
  
</ul>

      </div>
    
  


            

            <a href="http://typo.leetsoft.com/" class="powered"><img alt="Powered" src="/images/powered.gif" /></a>
            </div>

            <br clear="all" />
      </div>
      <div id="footer">
        <ul>
          <li><a href="http://validator.w3.org/check?uri=referer">Valid XHTML 1.0</a></li>
          <li><a href="http://jigsaw.w3.org/css-validator/validator?uri=http://www.randomhacks.net/">Valid CSS</a></li>
        </ul>
      </div>
  </div>
</body>
</html>

